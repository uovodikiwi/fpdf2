<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>fpdf API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>fpdf</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
from .fpdf import (
    FPDF,
    FPDF_CACHE_DIR as _FPDF_CACHE_DIR,
    FPDF_CACHE_MODE as _FPDF_CACHE_MODE,
    FPDF_FONT_DIR as _FPDF_FONT_DIR,
    FPDF_VERSION as _FPDF_VERSION,
    SYSTEM_TTFONTS as _SYSTEM_TTFONTS,
)
from .html import HTMLMixin
from .template import Template

FPDF_VERSION = _FPDF_VERSION
&#34;&#34;&#34;Current FPDF Version, also available via `__version__` (which is read by `setup.py`):

&lt;pre&gt;
&gt;&gt;&gt; import fpdf
&gt;&gt;&gt; fpdf.__version__
&#39;2.2.0&#39;
&lt;/pre&gt;
&#34;&#34;&#34;

FPDF_CACHE_MODE = _FPDF_CACHE_MODE

FPDF_CACHE_DIR = _FPDF_CACHE_DIR
&#34;&#34;&#34;This is the directory where pickle files for TTF font files are kept
containing meta-data and stuffs.
&#34;&#34;&#34;

FPDF_FONT_DIR = _FPDF_FONT_DIR
&#34;&#34;&#34;This is the location of where to look for fonts.&#34;&#34;&#34;

SYSTEM_TTFONTS = _SYSTEM_TTFONTS
&#34;&#34;&#34;This is the directory searched for fonts when a font file path is not given.
&#34;&#34;&#34;

__license__ = &#34;LGPL 3.0&#34;

__version__ = FPDF_VERSION


__all__ = [
    # metadata
    &#34;__version__&#34;,
    &#34;__license__&#34;,
    # Classes
    &#34;FPDF&#34;,
    &#34;Template&#34;,
    &#34;HTMLMixin&#34;,
    # FPDF Constants
    &#34;FPDF_VERSION&#34;,
    &#34;FPDF_CACHE_MODE&#34;,
    &#34;FPDF_CACHE_DIR&#34;,
    &#34;FPDF_FONT_DIR&#34;,
    &#34;SYSTEM_TTFONTS&#34;,
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="fpdf.errors" href="errors.html">fpdf.errors</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="fpdf.fonts" href="fonts.html">fpdf.fonts</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="fpdf.fpdf" href="fpdf.html">fpdf.fpdf</a></code></dt>
<dd>
<div class="desc"><p>fpdf module (in fpdf package housing FPDF class) â€¦</p></div>
</dd>
<dt><code class="name"><a title="fpdf.html" href="html.html">fpdf.html</a></code></dt>
<dd>
<div class="desc"><p>HTML Renderer for FPDF.py</p></div>
</dd>
<dt><code class="name"><a title="fpdf.image_parsing" href="image_parsing.html">fpdf.image_parsing</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="fpdf.recorder" href="recorder.html">fpdf.recorder</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="fpdf.template" href="template.html">fpdf.template</a></code></dt>
<dd>
<div class="desc"><p>PDF Template Helper for FPDF.py</p></div>
</dd>
<dt><code class="name"><a title="fpdf.ttfonts" href="ttfonts.html">fpdf.ttfonts</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="fpdf.util" href="util/index.html">fpdf.util</a></code></dt>
<dd>
<div class="desc"><p>Utility Functions</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="fpdf.FPDF_CACHE_DIR"><code class="name">var <span class="ident">FPDF_CACHE_DIR</span></code></dt>
<dd>
<div class="desc"><p>This is the directory where pickle files for TTF font files are kept
containing meta-data and stuffs.</p></div>
</dd>
<dt id="fpdf.FPDF_FONT_DIR"><code class="name">var <span class="ident">FPDF_FONT_DIR</span></code></dt>
<dd>
<div class="desc"><p>This is the location of where to look for fonts.</p></div>
</dd>
<dt id="fpdf.FPDF_VERSION"><code class="name">var <span class="ident">FPDF_VERSION</span></code></dt>
<dd>
<div class="desc"><p>Current FPDF Version, also available via <code>__version__</code> (which is read by <code>setup.py</code>):</p>
<pre>

<pre><code class="language-python-repl">&gt;&gt;&gt; import fpdf
&gt;&gt;&gt; fpdf.__version__
'2.2.0'
&lt;/pre&gt;
</code></pre></div>
</dd>
<dt id="fpdf.SYSTEM_TTFONTS"><code class="name">var <span class="ident">SYSTEM_TTFONTS</span></code></dt>
<dd>
<div class="desc"><p>This is the directory searched for fonts when a font file path is not given.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fpdf.FPDF"><code class="flex name class">
<span>class <span class="ident">FPDF</span></span>
<span>(</span><span>orientation='P', unit='mm', format='A4')</span>
</code></dt>
<dd>
<div class="desc"><p>PDF Generation class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FPDF:
    &#34;&#34;&#34;PDF Generation class&#34;&#34;&#34;

    def __init__(self, orientation=&#34;P&#34;, unit=&#34;mm&#34;, format=&#34;A4&#34;):
        # Initialization of properties
        self.offsets = {}  # array of object offsets
        self.page = 0  # current page number
        self.n = 2  # current object number
        self.buffer = bytearray()  # buffer holding in-memory PDF
        self.pages = {}  # array containing pages and metadata
        self.state = DocumentState.UNINITIALIZED  # current document state
        self.fonts = {}  # array of used fonts
        self.font_files = {}  # array of font files
        self.diffs = {}  # array of encoding differences
        self.images = {}  # array of used images
        self.page_links = {}  # array of links in pages
        self.links = {}  # array of internal links
        self.in_footer = 0  # flag set when processing footer
        self.lasth = 0  # height of last cell printed
        self.font_family = &#34;&#34;  # current font family
        self.font_style = &#34;&#34;  # current font style
        self.font_size_pt = 12  # current font size in points
        self.font_stretching = 100  # current font stretching
        self.str_alias_nb_pages = &#34;{nb}&#34;
        self.unifontsubset = False
        self.underline = 0  # underlining flag
        self.draw_color = &#34;0 G&#34;
        self.fill_color = &#34;0 g&#34;
        self.text_color = &#34;0 g&#34;
        self.ws = 0  # word spacing
        self.angle = 0  # used by deprecated method: rotate()

        # Standard fonts
        self.core_fonts = {
            &#34;courier&#34;: &#34;Courier&#34;,
            &#34;courierB&#34;: &#34;Courier-Bold&#34;,
            &#34;courierI&#34;: &#34;Courier-Oblique&#34;,
            &#34;courierBI&#34;: &#34;Courier-BoldOblique&#34;,
            &#34;helvetica&#34;: &#34;Helvetica&#34;,
            &#34;helveticaB&#34;: &#34;Helvetica-Bold&#34;,
            &#34;helveticaI&#34;: &#34;Helvetica-Oblique&#34;,
            &#34;helveticaBI&#34;: &#34;Helvetica-BoldOblique&#34;,
            &#34;times&#34;: &#34;Times-Roman&#34;,
            &#34;timesB&#34;: &#34;Times-Bold&#34;,
            &#34;timesI&#34;: &#34;Times-Italic&#34;,
            &#34;timesBI&#34;: &#34;Times-BoldItalic&#34;,
            &#34;symbol&#34;: &#34;Symbol&#34;,
            &#34;zapfdingbats&#34;: &#34;ZapfDingbats&#34;,
        }
        self.core_fonts_encoding = &#34;latin-1&#34;

        # Scale factor
        if unit == &#34;pt&#34;:
            self.k = 1
        elif unit == &#34;mm&#34;:
            self.k = 72 / 25.4
        elif unit == &#34;cm&#34;:
            self.k = 72 / 2.54
        elif unit == &#34;in&#34;:
            self.k = 72.0
        else:
            raise FPDFException(f&#34;Incorrect unit: {unit}&#34;)

        # Page format
        self.dw_pt, self.dh_pt = get_page_format(format, self.k)

        # Page orientation
        orientation = orientation.lower()
        if orientation in (&#34;p&#34;, &#34;portrait&#34;):
            self.def_orientation = &#34;P&#34;
            self.w_pt = self.dw_pt
            self.h_pt = self.dh_pt
        elif orientation in (&#34;l&#34;, &#34;landscape&#34;):
            self.def_orientation = &#34;L&#34;
            self.w_pt = self.dh_pt
            self.h_pt = self.dw_pt
        else:
            raise FPDFException(f&#34;Incorrect orientation: {orientation}&#34;)
        self.cur_orientation = self.def_orientation
        self.w = self.w_pt / self.k
        self.h = self.h_pt / self.k

        # Page spacing
        # Page margins (1 cm)
        margin = 28.35 / self.k
        self.set_margins(margin, margin)
        self.x = self.l_margin
        self.y = self.t_margin
        self.c_margin = margin / 10.0  # Interior cell margin (1 mm)
        self.line_width = 0.567 / self.k  # line width (0.2 mm)
        self.set_auto_page_break(
            True, 2 * margin
        )  # sets self.auto_page_break, self.b_margin &amp; self.page_break_trigger
        self.set_display_mode(&#34;fullwidth&#34;)  # Full width display mode
        self.compress = True  # Enable compression by default
        self.pdf_version = &#34;1.3&#34;  # Set default PDF version No.

    @property
    def epw(self):
        &#34;&#34;&#34;
        Effective page width: the page width minus its horizontal margins.
        &#34;&#34;&#34;
        return self.w - self.l_margin - self.r_margin

    @property
    def eph(self):
        &#34;&#34;&#34;
        Effective page height: the page height minus its vertical margins.
        &#34;&#34;&#34;
        return self.h - self.t_margin - self.b_margin

    def set_margins(self, left, top, right=-1):
        &#34;&#34;&#34;Set left, top and right margins&#34;&#34;&#34;
        self.l_margin = left
        self.t_margin = top
        if right == -1:
            right = left
        self.r_margin = right

    def set_left_margin(self, margin):
        &#34;&#34;&#34;Set left margin&#34;&#34;&#34;
        self.l_margin = margin
        if self.page &gt; 0 and self.x &lt; margin:
            self.x = margin

    def set_top_margin(self, margin):
        &#34;&#34;&#34;Set top margin&#34;&#34;&#34;
        self.t_margin = margin

    def set_right_margin(self, margin):
        &#34;&#34;&#34;Set right margin&#34;&#34;&#34;
        self.r_margin = margin

    def set_auto_page_break(self, auto, margin=0):
        &#34;&#34;&#34;Set auto page break mode and triggering margin&#34;&#34;&#34;
        self.auto_page_break = auto
        self.b_margin = margin
        self.page_break_trigger = self.h - margin

    def set_display_mode(self, zoom, layout=&#34;continuous&#34;):
        &#34;&#34;&#34;Set display mode in viewer

        The &#34;zoom&#34; argument may be &#39;fullpage&#39;, &#39;fullwidth&#39;, &#39;real&#39;,
        &#39;default&#39;, or a number, interpreted as a percentage.
        &#34;&#34;&#34;
        if zoom in [&#34;fullpage&#34;, &#34;fullwidth&#34;, &#34;real&#34;, &#34;default&#34;] or not isinstance(
            zoom, str
        ):
            self.zoom_mode = zoom
        else:
            raise FPDFException(f&#34;Incorrect zoom display mode: {zoom}&#34;)

        if layout in [&#34;single&#34;, &#34;continuous&#34;, &#34;two&#34;, &#34;default&#34;]:
            self.layout_mode = layout
        else:
            raise FPDFException(f&#34;Incorrect layout display mode: {layout}&#34;)

    def set_compression(self, compress):
        &#34;&#34;&#34;Set page compression&#34;&#34;&#34;
        self.compress = compress

    def set_title(self, title):
        &#34;&#34;&#34;Title of document&#34;&#34;&#34;
        self.title = title

    def set_subject(self, subject):
        &#34;&#34;&#34;Subject of document&#34;&#34;&#34;
        self.subject = subject

    def set_author(self, author):
        &#34;&#34;&#34;Author of document&#34;&#34;&#34;
        self.author = author

    def set_keywords(self, keywords):
        &#34;&#34;&#34;Keywords of document&#34;&#34;&#34;
        self.keywords = keywords

    def set_creator(self, creator):
        &#34;&#34;&#34;Creator of document&#34;&#34;&#34;
        self.creator = creator

    def set_creation_date(self, date=None):
        &#34;&#34;&#34;Sets Creation of Date time, or current time if None given.&#34;&#34;&#34;
        self.creation_date = datetime.now() if date is None else date

    def set_doc_option(self, opt, value):
        &#34;&#34;&#34;Set document option&#34;&#34;&#34;
        if opt == &#34;core_fonts_encoding&#34;:
            self.core_fonts_encoding = value
        else:
            raise FPDFException(f&#39;Unknown document option &#34;{opt}&#34;&#39;)

    def alias_nb_pages(self, alias):
        &#34;&#34;&#34;Define an alias for total number of pages&#34;&#34;&#34;
        self.str_alias_nb_pages = alias

    def open(self):
        &#34;&#34;&#34;Begin document&#34;&#34;&#34;
        self.state = DocumentState.READY

    def close(self):
        &#34;&#34;&#34;Terminate document&#34;&#34;&#34;
        if self.state == DocumentState.CLOSED:
            return
        if self.page == 0:
            self.add_page()

        # Page footer
        self.in_footer = 1
        self.footer()
        self.in_footer = 0

        self._endpage()  # close page
        self._enddoc()  # close document

    def add_page(self, orientation=&#34;&#34;, format=&#34;&#34;, same=False):
        &#34;&#34;&#34;Start a new page, if same page format will be same as previous&#34;&#34;&#34;
        if self.state == DocumentState.CLOSED:
            raise FPDFException(
                &#34;A page cannot be added on a closed document, after calling output()&#34;
            )
        if self.state == DocumentState.UNINITIALIZED:
            self.open()
        family = self.font_family
        style = f&#34;{self.font_style}U&#34; if self.underline else self.font_style
        size = self.font_size_pt
        lw = self.line_width
        dc = self.draw_color
        fc = self.fill_color
        tc = self.text_color
        stretching = self.font_stretching
        if self.page &gt; 0:
            # Page footer
            self.in_footer = 1
            self.footer()
            self.in_footer = 0
            # close page
            self._endpage()

        # Start new page
        self._beginpage(orientation, format, same)
        self._out(&#34;2 J&#34;)  # Set line cap style to square
        self.line_width = lw  # Set line width
        self._out(f&#34;{lw * self.k:.2f} w&#34;)

        # Set font
        if family:
            self.set_font(family, style, size)

        # Set colors
        self.draw_color = dc
        if dc != &#34;0 G&#34;:
            self._out(dc)
        self.fill_color = fc
        if fc != &#34;0 g&#34;:
            self._out(fc)
        self.text_color = tc

        # BEGIN Page header
        self.header()

        if self.line_width != lw:  # Restore line width
            self.line_width = lw
            self._out(f&#34;{lw * self.k:.2f} w&#34;)

        if family:
            self.set_font(family, style, size)  # Restore font

        if self.draw_color != dc:  # Restore colors
            self.draw_color = dc
            self._out(dc)
        if self.fill_color != fc:
            self.fill_color = fc
            self._out(fc)
        self.text_color = tc

        if stretching != 100:  # Restore stretching
            self.set_stretching(stretching)
        # END Page header

    def header(self):
        &#34;&#34;&#34;Header to be implemented in your own inherited class&#34;&#34;&#34;

    def footer(self):
        &#34;&#34;&#34;Footer to be implemented in your own inherited class&#34;&#34;&#34;

    def page_no(self):
        &#34;&#34;&#34;Get current page number&#34;&#34;&#34;
        return self.page

    def set_draw_color(self, r, g=-1, b=-1):
        &#34;&#34;&#34;Set color for all stroking operations&#34;&#34;&#34;
        if (r == 0 and g == 0 and b == 0) or g == -1:
            self.draw_color = f&#34;{r / 255:.3f} G&#34;
        else:
            self.draw_color = f&#34;{r / 255:.3f} {g / 255:.3f} {b / 255:.3f} RG&#34;
        if self.page &gt; 0:
            self._out(self.draw_color)

    def set_fill_color(self, r, g=-1, b=-1):
        &#34;&#34;&#34;Set color for all filling operations&#34;&#34;&#34;
        if (r == 0 and g == 0 and b == 0) or g == -1:
            self.fill_color = f&#34;{r / 255:.3f} g&#34;
        else:
            self.fill_color = f&#34;{r / 255:.3f} {g / 255:.3f} {b / 255:.3f} rg&#34;
        if self.page &gt; 0:
            self._out(self.fill_color)

    def set_text_color(self, r, g=-1, b=-1):
        &#34;&#34;&#34;Set color for text&#34;&#34;&#34;
        if (r == 0 and g == 0 and b == 0) or g == -1:
            self.text_color = f&#34;{r / 255:.3f} g&#34;
        else:
            self.text_color = f&#34;{r / 255:.3f} {g / 255:.3f} {b / 255:.3f} rg&#34;

    def get_string_width(self, s, normalized=False):
        &#34;&#34;&#34;Get width of a string in the current font&#34;&#34;&#34;
        # normalized is parameter for internal use
        s = s if normalized else self.normalize_text(s)
        cw = self.current_font[&#34;cw&#34;]
        w = 0
        if self.unifontsubset:
            for char in s:
                char = ord(char)
                if len(cw) &gt; char:
                    w += cw[char]
                elif self.current_font[&#34;desc&#34;][&#34;MissingWidth&#34;]:
                    w += self.current_font[&#34;desc&#34;][&#34;MissingWidth&#34;]
                else:
                    w += 500
        else:
            w += sum(cw.get(char, 0) for char in s)
        if self.font_stretching != 100:
            w = w * self.font_stretching / 100
        return w * self.font_size / 1000

    def set_line_width(self, width):
        &#34;&#34;&#34;Set line width&#34;&#34;&#34;
        self.line_width = width
        if self.page &gt; 0:
            self._out(f&#34;{width * self.k:.2f} w&#34;)

    @check_page
    def line(self, x1, y1, x2, y2):
        &#34;&#34;&#34;Draw a line&#34;&#34;&#34;
        self._out(
            f&#34;{x1 * self.k:.2f} {(self.h - y1) * self.k:.2f} m {x2 * self.k:.2f} &#34;
            f&#34;{(self.h - y2) * self.k:.2f} l S&#34;
        )

    def _set_dash(self, dash_length=False, space_length=False):
        if dash_length and space_length:
            s = f&#34;[{dash_length * self.k:.3f} {space_length * self.k:.3f}] 0 d&#34;
        else:
            s = &#34;[] 0 d&#34;
        self._out(s)

    @check_page
    def dashed_line(self, x1, y1, x2, y2, dash_length=1, space_length=1):
        &#34;&#34;&#34;Draw a dashed line. Same interface as line() except:
        - dash_length: Length of the dash
        - space_length: Length of the space between dashes&#34;&#34;&#34;
        self._set_dash(dash_length, space_length)
        self.line(x1, y1, x2, y2)
        self._set_dash()

    @check_page
    def rect(self, x, y, w, h, style=None):
        &#34;&#34;&#34;Draw a rectangle&#34;&#34;&#34;
        style_to_operators = {&#34;F&#34;: &#34;f&#34;, &#34;FD&#34;: &#34;B&#34;, &#34;DF&#34;: &#34;B&#34;}
        op = style_to_operators.get(style, &#34;S&#34;)
        self._out(
            f&#34;{x * self.k:.2f} {(self.h - y) * self.k:.2f} {w * self.k:.2f} &#34;
            f&#34;{-h * self.k:.2f} re {op}&#34;
        )

    @check_page
    def ellipse(self, x, y, w, h, style=None):
        &#34;&#34;&#34;Draw a ellipse&#34;&#34;&#34;
        style_to_operators = {&#34;F&#34;: &#34;f&#34;, &#34;FD&#34;: &#34;B&#34;, &#34;DF&#34;: &#34;B&#34;}
        op = style_to_operators.get(style, &#34;S&#34;)

        cx = x + w / 2
        cy = y + h / 2
        rx = w / 2
        ry = h / 2

        lx = 4 / 3 * (math.sqrt(2) - 1) * rx
        ly = 4 / 3 * (math.sqrt(2) - 1) * ry

        self._out(
            (
                f&#34;{(cx + rx) * self.k:.2f} {(self.h - cy) * self.k:.2f} m &#34;
                f&#34;{(cx + rx) * self.k:.2f} {(self.h - cy + ly) * self.k:.2f} &#34;
                f&#34;{(cx + lx) * self.k:.2f} {(self.h - cy + ry) * self.k:.2f} &#34;
                f&#34;{cx * self.k:.2f} {(self.h - cy + ry) * self.k:.2f} c&#34;
            )
        )
        self._out(
            (
                f&#34;{(cx - lx) * self.k:.2f} {(self.h - cy + ry) * self.k:.2f} &#34;
                f&#34;{(cx - rx) * self.k:.2f} {(self.h - cy + ly) * self.k:.2f} &#34;
                f&#34;{(cx - rx) * self.k:.2f} {(self.h - cy) * self.k:.2f} c&#34;
            )
        )
        self._out(
            (
                f&#34;{(cx - rx) * self.k:.2f} {(self.h - cy - ly) * self.k:.2f} &#34;
                f&#34;{(cx - lx) * self.k:.2f} {(self.h - cy - ry) * self.k:.2f} &#34;
                f&#34;{cx * self.k:.2f} {(self.h - cy - ry) * self.k:.2f} c&#34;
            )
        )
        self._out(
            (
                f&#34;{(cx + lx) * self.k:.2f} {(self.h - cy - ry) * self.k:.2f} &#34;
                f&#34;{(cx + rx) * self.k:.2f} {(self.h - cy - ly) * self.k:.2f} &#34;
                f&#34;{(cx + rx) * self.k:.2f} {(self.h - cy) * self.k:.2f} c {op}&#34;
            )
        )

    def add_font(self, family, style=&#34;&#34;, fname=None, uni=False):
        &#34;&#34;&#34;Add a TrueType or Type1 font&#34;&#34;&#34;
        if not fname:
            fname = family.replace(&#34; &#34;, &#34;&#34;) + f&#34;{style.lower()}.pkl&#34;
        style = &#34;&#34;.join(sorted(style.upper()))
        if any(letter not in &#34;BI&#34; for letter in style):
            raise ValueError(
                f&#34;Unknown style provided (only B &amp; I letters are allowed): {style}&#34;
            )
        fontkey = f&#34;{family}{style}&#34;

        # Font already added!
        if fontkey in self.fonts:
            return
        if uni:
            for parent in (&#34;.&#34;, FPDF_FONT_DIR, SYSTEM_TTFONTS):
                if (Path(parent) / fname).exists():
                    ttffilename = Path(parent) / fname
                    break
            else:
                raise RuntimeError(f&#34;TTF Font file not found: {fname}&#34;)
            if FPDF_CACHE_MODE == 0:
                unifilename = Path() / f&#34;{ttffilename.stem}.pkl&#34;
            elif FPDF_CACHE_MODE == 2:
                unifilename = FPDF_CACHE_DIR / f&#34;{_hashpath(ttffilename)}.pkl&#34;
            else:
                unifilename = None

            font_dict = load_cache(unifilename)
            if font_dict is None:
                ttf = TTFontFile()
                ttf.getMetrics(ttffilename)
                desc = {
                    &#34;Ascent&#34;: round(ttf.ascent),
                    &#34;Descent&#34;: round(ttf.descent),
                    &#34;CapHeight&#34;: round(ttf.capHeight),
                    &#34;Flags&#34;: ttf.flags,
                    &#34;FontBBox&#34;: (
                        f&#34;[{ttf.bbox[0]:.0f} {ttf.bbox[1]:.0f}&#34;
                        f&#34; {ttf.bbox[2]:.0f} {ttf.bbox[3]:.0f}]&#34;
                    ),
                    &#34;ItalicAngle&#34;: int(ttf.italicAngle),
                    &#34;StemV&#34;: round(ttf.stemV),
                    &#34;MissingWidth&#34;: round(ttf.defaultWidth),
                }

                # Generate metrics .pkl file
                font_dict = {
                    &#34;name&#34;: re.sub(&#34;[ ()]&#34;, &#34;&#34;, ttf.fullName),
                    &#34;type&#34;: &#34;TTF&#34;,
                    &#34;desc&#34;: desc,
                    &#34;up&#34;: round(ttf.underlinePosition),
                    &#34;ut&#34;: round(ttf.underlineThickness),
                    &#34;ttffile&#34;: ttffilename,
                    &#34;fontkey&#34;: fontkey,
                    &#34;originalsize&#34;: os.stat(ttffilename).st_size,
                    &#34;cw&#34;: ttf.charWidths,
                }

                if unifilename:
                    try:
                        unifilename.write_bytes(pickle.dumps(font_dict))
                    except OSError as e:
                        if e.errno != errno.EACCES:
                            raise  # Not a permission error.
                del ttf

            # include numbers in the subset! (if alias present)
            sbarr = list(range(57 if self.str_alias_nb_pages else 32))

            self.fonts[fontkey] = {
                &#34;i&#34;: len(self.fonts) + 1,
                &#34;type&#34;: font_dict[&#34;type&#34;],
                &#34;name&#34;: font_dict[&#34;name&#34;],
                &#34;desc&#34;: font_dict[&#34;desc&#34;],
                &#34;up&#34;: font_dict[&#34;up&#34;],
                &#34;ut&#34;: font_dict[&#34;ut&#34;],
                &#34;cw&#34;: font_dict[&#34;cw&#34;],
                &#34;ttffile&#34;: font_dict[&#34;ttffile&#34;],
                &#34;fontkey&#34;: fontkey,
                &#34;subset&#34;: sbarr,
                &#34;unifilename&#34;: unifilename,
            }
            self.font_files[fontkey] = {
                &#34;length1&#34;: font_dict[&#34;originalsize&#34;],
                &#34;type&#34;: &#34;TTF&#34;,
                &#34;ttffile&#34;: ttffilename,
            }
            self.font_files[fname] = {&#34;type&#34;: &#34;TTF&#34;}
        else:
            font_dict = pickle.loads(fname.read_bytes())
            self.fonts[fontkey] = {&#34;i&#34;: len(self.fonts) + 1}
            self.fonts[fontkey].update(font_dict)
            diff = font_dict.get(&#34;diff&#34;)
            if diff:
                # Search existing encodings
                nb = len(self.diffs)
                for i in range(1, nb + 1):
                    if self.diffs[i] == diff:
                        d = i
                        break
                else:
                    d = nb + 1
                    self.diffs[d] = diff
                self.fonts[fontkey][&#34;diff&#34;] = d
            filename = font_dict.get(&#34;filename&#34;)
            if filename:
                if font_dict[&#34;type&#34;] == &#34;TrueType&#34;:
                    originalsize = font_dict[&#34;originalsize&#34;]
                    self.font_files[filename] = {&#34;length1&#34;: originalsize}
                else:
                    self.font_files[filename] = {
                        &#34;length1&#34;: font_dict[&#34;size1&#34;],
                        &#34;length2&#34;: font_dict[&#34;size2&#34;],
                    }

    def set_font(self, family=None, style=&#34;&#34;, size=0):
        &#34;&#34;&#34;
        Select a font.

        Args:
            family (str): name of a font added with `FPDF.add_font`,
              or name of one of the 14 standard &#34;PostScript&#34; fonts
            style (str): empty string (by default) or a combination
              of one or several letters among B, I, U to
            size (int): in points
        &#34;&#34;&#34;
        if not family:
            family = self.font_family
        if family.lower() == &#34;arial&#34; and (family + style) not in self.fonts:
            warnings.warn(&#34;Substitutting Arial by core font Helvetica&#34;)
            family = &#34;helvetica&#34;
        elif family.lower() in (&#34;symbol&#34;, &#34;zapfdingbats&#34;) and style:
            warnings.warn(
                &#39;Built-in fonts Symbol &amp; Zapfdingbats only have a single &#34;style&#34;&#39;
            )
            style = &#34;&#34;
        style = &#34;&#34;.join(sorted(style.upper()))
        if any(letter not in &#34;BIU&#34; for letter in style):
            raise ValueError(
                f&#34;Unknown style provided (only B/I/U letters are allowed): {style}&#34;
            )
        if &#34;U&#34; in style:
            self.underline = 1
            style = style.replace(&#34;U&#34;, &#34;&#34;)
        else:
            self.underline = 0
        if size == 0:
            size = self.font_size_pt

        # Test if font is already selected
        if (
            self.font_family == family
            and self.font_style == style
            and self.font_size_pt == size
        ):
            return

        # Test if used for the first time
        fontkey = family + style
        if fontkey not in self.fonts:
            # Being flexible: try a fontkey with lowercase family:
            fontkey_alt = family.lower() + style
            if fontkey_alt in self.fonts:
                fontkey = fontkey_alt
            else:
                if fontkey not in self.core_fonts or fontkey not in fpdf_charwidths:
                    fontkey = fontkey_alt
                    if fontkey not in self.core_fonts or fontkey not in fpdf_charwidths:
                        raise FPDFException(
                            &#34;Undefined font: &#34;
                            + fontkey
                            + &#34; - Use built-in fonts or FPDF.add_font() beforehand&#34;
                        )
                i = len(self.fonts) + 1
                self.fonts[fontkey] = {
                    &#34;i&#34;: i,
                    &#34;type&#34;: &#34;core&#34;,
                    &#34;name&#34;: self.core_fonts[fontkey],
                    &#34;up&#34;: -100,
                    &#34;ut&#34;: 50,
                    &#34;cw&#34;: fpdf_charwidths[fontkey],
                }

        # Select it
        self.font_family = family
        self.font_style = style
        self.font_size_pt = size
        self.font_size = size / self.k
        self.current_font = self.fonts[fontkey]
        self.unifontsubset = self.current_font[&#34;type&#34;] == &#34;TTF&#34;
        if self.page &gt; 0:
            self._out(f&#34;BT /F{self.current_font[&#39;i&#39;]} {self.font_size_pt:.2f} Tf ET&#34;)

    def set_font_size(self, size):
        &#34;&#34;&#34;Set font size in points&#34;&#34;&#34;
        if self.font_size_pt == size:
            return
        self.font_size_pt = size
        self.font_size = size / self.k
        if self.page &gt; 0:
            self._out(f&#34;BT /F{self.current_font[&#39;i&#39;]} {self.font_size_pt:.2f} Tf ET&#34;)

    def set_stretching(self, factor):
        &#34;&#34;&#34;Set from stretch factor percents (default: 100.0)&#34;&#34;&#34;
        if self.font_stretching == factor:
            return
        self.font_stretching = factor
        if self.page &gt; 0:
            self._out(f&#34;BT {self.font_stretching:.2f} Tz ET&#34;)

    def add_link(self):
        &#34;&#34;&#34;Create a new internal link&#34;&#34;&#34;
        n = len(self.links) + 1
        self.links[n] = (0, 0)
        return n

    def set_link(self, link, y=0, page=-1):
        &#34;&#34;&#34;Set destination of internal link&#34;&#34;&#34;
        if y == -1:
            y = self.y
        if page == -1:
            page = self.page

        self.links[link] = [page, y]

    def link(self, x, y, w, h, link, alt_text=&#34;&#34;):
        &#34;&#34;&#34;Put a link on the page&#34;&#34;&#34;
        if self.page not in self.page_links:
            self.page_links[self.page] = []
        self.page_links[self.page] += [
            (x * self.k, self.h_pt - y * self.k, w * self.k, h * self.k, link, alt_text)
        ]

    @check_page
    def text(self, x, y, txt=&#34;&#34;):
        &#34;&#34;&#34;Output a string&#34;&#34;&#34;
        if not self.font_family:
            raise FPDFException(&#34;No font set, you need to call set_font() beforehand&#34;)
        txt = self.normalize_text(txt)
        if self.unifontsubset:
            txt2 = escape_parens(txt).encode(&#34;UTF-16BE&#34;).decode(&#34;latin-1&#34;)
            for char in txt:
                self.current_font[&#34;subset&#34;].append(ord(char))
        else:
            txt2 = escape_parens(txt)
        s = f&#34;BT {x * self.k:.2f} {(self.h - y) * self.k:.2f} Td ({txt2}) Tj ET&#34;
        if self.underline and txt != &#34;&#34;:
            s += &#34; &#34; + self._dounderline(x, y, txt)
        if self.fill_color != self.text_color:
            s = f&#34;q {self.text_color} {s} Q&#34;
        self._out(s)

    @check_page
    def rotate(self, angle, x=None, y=None):
        &#34;&#34;&#34;
        .. deprecated:: 2.1.0
          Use `rotation` instead.
        &#34;&#34;&#34;
        warnings.warn(
            &#34;rotate() can produces malformed PDFs and is deprecated. &#34;
            &#34;Use the rotation() context manager instead.&#34;,
            PendingDeprecationWarning,
        )
        if x is None:
            x = self.x
        if y is None:
            y = self.y

        if self.angle != 0:
            self._out(&#34;Q&#34;)
        self.angle = angle
        if angle != 0:
            angle *= math.pi / 180
            c = math.cos(angle)
            s = math.sin(angle)
            cx = x * self.k
            cy = (self.h - y) * self.k
            s = (
                f&#34;q {c:.5F} {s:.5F} {-s:.5F} {c:.5F} {cx:.2F} {cy:.2F} cm &#34;
                f&#34;1 0 0 1 {-cx:.2F} {-cy:.2F} cm&#34;
            )
            self._out(s)

    @check_page
    @contextmanager
    def rotation(self, angle, x=None, y=None):
        &#34;&#34;&#34;
        This method allows to perform a rotation around a given center.

        The rotation affects all elements which are printed inside the indented context
        (with the exception of clickable areas).

        Notes
        -----

        Only the rendering is altered. The `get_x()` and `get_y()` methods are not
        affected, nor the automatic page break mechanism.
        &#34;&#34;&#34;
        if x is None:
            x = self.x
        if y is None:
            y = self.y
        angle *= math.pi / 180
        c, s = math.cos(angle), math.sin(angle)
        cx, cy = x * self.k, (self.h - y) * self.k
        s = (
            f&#34;q {c:.5F} {s:.5F} {-s:.5F} {c:.5F} {cx:.2F} {cy:.2F} cm &#34;
            f&#34;1 0 0 1 {-cx:.2F} {-cy:.2F} cm\n&#34;
        )
        self._out(s)
        yield
        self._out(&#34;Q\n&#34;)

    @property
    def accept_page_break(self):
        &#34;&#34;&#34;Accept automatic page break or not&#34;&#34;&#34;
        return self.auto_page_break

    @check_page
    def cell(self, w, h=0, txt=&#34;&#34;, border=0, ln=0, align=&#34;&#34;, fill=False, link=&#34;&#34;):
        &#34;&#34;&#34;
        Output a cell, cf. https://pyfpdf.github.io/fpdf2/reference/cell.html

        Args:
            w (int): Cell width. If 0, the cell extends up to the right margin.
            h (int): Cell height. Default value: 0.
            txt (str): String to print. Default value: empty string.
            border: Indicates if borders must be drawn around the cell.
                The value can be either a number (`0`: no border ; `1`: frame)
                or a string containing some or all of the following characters
                (in any order):
                `L`: left ; `T`: top ; `R`: right ; `B`: bottom. Default value: 0.
            ln (int): Indicates where the current position should go after the call.
                Possible values are: `0`: to the right ; `1`: to the beginning of the
                next line ; `2`: below. Putting 1 is equivalent to putting 0 and calling
                `ln` just after. Default value: 0.
            align (str): Allows to center or align the text. Possible values are:
                `L` or empty string: left align (default value) ; `C`: center ;
                `R`: right align
            fill (bool): Indicates if the cell background must be painted (`True`)
                or transparent (`False`). Default value: False.
            link (str): optional link to add

        Returns: a boolean indicating if page break was triggered
        &#34;&#34;&#34;
        if not self.font_family:
            raise FPDFException(&#34;No font set, you need to call set_font() beforehand&#34;)
        if isinstance(border, int) and border not in (0, 1):
            warnings.warn(
                &#39;Integer values for &#34;border&#34; parameter other than 1 are currently &#39;
                &#34;ignored&#34;
            )
            border = 1
        page_break_triggered = self.perform_page_break_if_need_be(h)
        if w == 0:
            w = self.w - self.r_margin - self.x
        s = &#34;&#34;

        k = self.k
        if fill:
            op = &#34;B&#34; if border == 1 else &#34;f&#34;
            s = (
                f&#34;{self.x * k:.2f} {(self.h - self.y) * k:.2f} &#34;
                f&#34;{w * k:.2f} {-h * k:.2f} re {op} &#34;
            )
        elif border == 1:
            s = (
                f&#34;{self.x * k:.2f} {(self.h - self.y) * k:.2f} &#34;
                f&#34;{w * k:.2f} {-h * k:.2f} re S &#34;
            )

        if isinstance(border, str):
            x = self.x
            y = self.y
            if &#34;L&#34; in border:
                s += (
                    f&#34;{x * k:.2f} {(self.h - y) * k:.2f} m &#34;
                    f&#34;{x * k:.2f} {(self.h - (y + h)) * k:.2f} l S &#34;
                )
            if &#34;T&#34; in border:
                s += (
                    f&#34;{x * k:.2f} {(self.h - y) * k:.2f} m &#34;
                    f&#34;{(x + w) * k:.2f} {(self.h - y) * k:.2f} l S &#34;
                )
            if &#34;R&#34; in border:
                s += (
                    f&#34;{(x + w) * k:.2f} {(self.h - y) * k:.2f} m &#34;
                    f&#34;{(x + w) * k:.2f} {(self.h - (y + h)) * k:.2f} l S &#34;
                )
            if &#34;B&#34; in border:
                s += (
                    f&#34;{x * k:.2f} {(self.h - (y + h)) * k:.2f} m &#34;
                    f&#34;{(x + w) * k:.2f} {(self.h - (y + h)) * k:.2f} l S &#34;
                )

        txt = self.normalize_text(txt)
        if txt != &#34;&#34;:
            if align == &#34;R&#34;:
                dx = w - self.c_margin - self.get_string_width(txt, True)
            elif align == &#34;C&#34;:
                dx = (w - self.get_string_width(txt, True)) / 2
            else:
                dx = self.c_margin
            if self.fill_color != self.text_color:
                s += f&#34;q {self.text_color} &#34;

            # If multibyte, Tw has no effect - do word spacing using an
            # adjustment before each space
            if self.ws and self.unifontsubset:
                for char in txt:
                    self.current_font[&#34;subset&#34;].append(ord(char))
                space = escape_parens(&#34; &#34;.encode(&#34;UTF-16BE&#34;).decode(&#34;latin-1&#34;))

                s += (
                    f&#34;BT 0 Tw {(self.x + dx) * k:.2F} &#34;
                    f&#34;{(self.h - self.y - 0.5 * h - 0.3 * self.font_size) * k:.2F} &#34;
                    f&#34;Td [&#34;
                )

                t = txt.split(&#34; &#34;)
                numt = len(t)
                for i in range(numt):
                    tx = t[i]
                    tx = enclose_in_parens(
                        escape_parens(tx.encode(&#34;UTF-16BE&#34;).decode(&#34;latin-1&#34;))
                    )
                    s += f&#34;{tx} &#34;
                    if (i + 1) &lt; numt:
                        adj = -(self.ws * self.k) * 1000 / self.font_size_pt
                        s += f&#34;{adj}({space}) &#34;
                s += &#34;] TJ&#34;
                s += &#34; ET&#34;
            else:
                if self.unifontsubset:
                    txt2 = escape_parens(txt.encode(&#34;UTF-16BE&#34;).decode(&#34;latin-1&#34;))
                    for char in txt:
                        self.current_font[&#34;subset&#34;].append(ord(char))
                else:
                    txt2 = escape_parens(txt)

                s += (
                    f&#34;BT {(self.x + dx) * k:.2f} &#34;
                    f&#34;{(self.h - self.y - 0.5 * h - 0.3 * self.font_size) * k:.2f} &#34;
                    f&#34;Td ({txt2}) Tj ET&#34;
                )

            if self.underline:
                s += &#34; &#34; + self._dounderline(
                    self.x + dx, self.y + (0.5 * h) + (0.3 * self.font_size), txt
                )
            if self.fill_color != self.text_color:
                s += &#34; Q&#34;
            if link:
                self.link(
                    self.x + dx,
                    self.y + (0.5 * h) - (0.5 * self.font_size),
                    self.get_string_width(txt, True),
                    self.font_size,
                    link,
                )
        if s:
            self._out(s)
        self.lasth = h

        if ln &gt; 0:
            self.y += h  # Go to next line
            if ln == 1:
                self.x = self.l_margin
        else:
            self.x += w

        return page_break_triggered

    def perform_page_break_if_need_be(self, h):
        if (
            self.y + h &gt; self.page_break_trigger
            and not self.in_footer
            and self.accept_page_break
        ):
            LOGGER.info(
                &#34;Page break on page %d at y=%d for element of height %d&#34;,
                self.page,
                self.y,
                h,
            )
            x, ws = self.x, self.ws
            if ws &gt; 0:
                self.ws = 0
                self._out(&#34;0 Tw&#34;)
            self.add_page(same=True)
            self.x = x  # restore x but not y after drawing header
            if ws &gt; 0:
                self.ws = ws
                self._out(f&#34;{ws * self.k:.3f} Tw&#34;)
            return True
        return False

    @check_page
    def multi_cell(
        self,
        w,
        h,
        txt=&#34;&#34;,
        border=0,
        align=&#34;J&#34;,
        fill=False,
        split_only=False,
        link=&#34;&#34;,
        ln=0,
        max_line_height=None,
    ):
        &#34;&#34;&#34;
        Output text with line breaks, cf.
        https://pyfpdf.github.io/fpdf2/reference/multi_cell.html

        Args:
            w (int): cells width. If 0, they extend up to the right margin of the page.
            h (int): cells height.
            txt (str): strign to print.
            border: Indicates if borders must be drawn around the cell.
                The value can be either a number (`0`: no border ; `1`: frame)
                or a string containing some or all of the following characters
                (in any order):
                `L`: left ; `T`: top ; `R`: right ; `B`: bottom. Default value: 0.
            align (str): Allows to center or align the text. Possible values are:
                `L` or empty string: left align (default value) ; `C`: center ;
                `R`: right align
            fill (bool): Indicates if the cell background must be painted (`True`)
                or transparent (`False`). Default value: False.
            split_only (bool): if `True`, does not output anything, only perform
                word-wrapping and return the resulting multi-lines array of strings.
            link (str): optional link to add
            ln (int): Indicates where the current position should go after the call.
                Possible values are: `0`: to the bottom right ; `1`: to the beginning
                of the next line ; `2`: below with the same horizontal offset ;
                `3`: to the right with the same vertical offset. Default value: 0.
            max_line_height (int): optional maximum height of each sub-cell generated

        Using `ln=3` and `maximum height=pdf.font_size` is useful to build tables
        with multiline text in cells.

        Returns: a boolean indicating if page break was triggered.
        &#34;&#34;&#34;
        page_break_triggered = False
        if split_only:
            _out, _add_page = self._out, self.add_page
            self._out = lambda *args, **kwargs: None
            self.add_page = lambda *args, **kwargs: None

        # Store this information for manipulating position.
        location = (self.get_x(), self.get_y())

        # If width is 0, set width to available width between margins
        if w == 0:
            w = self.w - self.r_margin - self.x
        wmax = (w - 2 * self.c_margin) * 1000 / self.font_size

        # Calculate text length
        txt = self.normalize_text(txt)
        s = txt.replace(&#34;\r&#34;, &#34;&#34;)
        normalized_string_length = len(s)
        if normalized_string_length &gt; 0 and s[-1] == &#34;\n&#34;:
            normalized_string_length -= 1

        b = 0
        if border:
            if border == 1:
                border = &#34;LTRB&#34;
                b = &#34;LRT&#34;
                b2 = &#34;LR&#34;
            else:
                b2 = &#34;&#34;
                if &#34;L&#34; in border:
                    b2 += &#34;L&#34;
                if &#34;R&#34; in border:
                    b2 += &#34;R&#34;
                b = b2 + &#34;T&#34; if &#34;T&#34; in border else b2
        character_widths = self.current_font[&#34;cw&#34;]
        text_cells = []
        sep = -1
        i = 0
        j = 0
        l = 0
        ns = 0
        nl = 1
        prev_x, prev_y = self.x, self.y
        while i &lt; normalized_string_length:
            # Get next character
            c = s[i]

            # Explicit line break
            if c == &#34;\n&#34;:
                if self.ws &gt; 0:
                    self.ws = 0
                    self._out(&#34;0 Tw&#34;)

                if max_line_height and h &gt; max_line_height:
                    height = max_line_height
                    h -= height
                else:
                    height = h
                new_page = self.cell(
                    w,
                    h=height,
                    txt=substr(s, j, i - j),
                    border=b,
                    ln=2,
                    align=align,
                    fill=fill,
                    link=link,
                )
                page_break_triggered = page_break_triggered or new_page
                text_cells.append(substr(s, j, i - j))

                i += 1
                sep = -1
                j = i
                l = 0
                ns = 0
                nl += 1
                if border and nl == 2:
                    b = b2
                continue

            if c == &#34; &#34;:
                sep = i
                ls = l
                ns += 1
            if self.unifontsubset:
                l += self.get_string_width(c, True) / self.font_size * 1000
            else:
                l += character_widths.get(c, 0)

            # Automatic line break
            if l &gt; wmax:
                if sep == -1:
                    if i == j:
                        i += 1
                    if self.ws &gt; 0:
                        self.ws = 0
                        self._out(&#34;0 Tw&#34;)

                    if max_line_height and h &gt; max_line_height:
                        height = max_line_height
                        h -= height
                    else:
                        height = h
                    new_page = self.cell(
                        w,
                        h=height,
                        txt=substr(s, j, i - j),
                        border=b,
                        ln=2,
                        align=align,
                        fill=fill,
                        link=link,
                    )
                    page_break_triggered = page_break_triggered or new_page
                    text_cells.append(substr(s, j, i - j))

                else:
                    if align == &#34;J&#34;:
                        self.ws = (
                            (wmax - ls) / 1000 * self.font_size / (ns - 1)
                            if ns &gt; 1
                            else 0
                        )
                        self._out(f&#34;{self.ws * self.k:.3f} Tw&#34;)

                    if max_line_height and h &gt; max_line_height:
                        height = max_line_height
                        h -= height
                    else:
                        height = h
                    new_page = self.cell(
                        w,
                        h=height,
                        txt=substr(s, j, sep - j),
                        border=b,
                        ln=2,
                        align=align,
                        fill=fill,
                        link=link,
                    )
                    page_break_triggered = page_break_triggered or new_page
                    text_cells.append(substr(s, j, sep - j))

                    i = sep + 1
                sep = -1
                j = i
                l = 0
                ns = 0
                nl += 1
                if border and nl == 2:
                    b = b2
            else:
                i += 1

        # Last chunk
        if self.ws &gt; 0:
            self.ws = 0
            self._out(&#34;0 Tw&#34;)
        if border and &#34;B&#34; in border:
            b += &#34;B&#34;

        new_page = self.cell(
            w,
            h=h,
            txt=substr(s, j, i - j),
            border=b,
            ln=0 if ln == 3 else ln,
            align=align,
            fill=fill,
            link=link,
        )
        page_break_triggered = page_break_triggered or new_page
        text_cells.append(substr(s, j, i - j))

        new_x, new_y = {
            0: (self.x, self.y + h),
            1: (self.l_margin, self.y),
            2: (prev_x, self.y),
            3: (self.x, prev_y),
        }[ln]
        self.set_xy(new_x, new_y)

        if split_only:
            # restore writing functions
            self._out, self.add_page = _out, _add_page
            self.set_xy(*location)  # restore location
            return text_cells

        return page_break_triggered

    @check_page
    def write(self, h, txt=&#34;&#34;, link=&#34;&#34;):
        &#34;&#34;&#34;Output text in flowing mode&#34;&#34;&#34;
        if not self.font_family:
            raise FPDFException(&#34;No font set, you need to call set_font() beforehand&#34;)
        txt = self.normalize_text(txt)
        cw = self.current_font[&#34;cw&#34;]
        w = self.w - self.r_margin - self.x
        wmax = (w - 2 * self.c_margin) * 1000 / self.font_size
        s = txt.replace(&#34;\r&#34;, &#34;&#34;)
        nb = len(s)
        sep = -1
        i = 0
        j = 0
        l = 0
        nl = 1
        while i &lt; nb:
            # Get next character
            c = s[i]
            if c == &#34;\n&#34;:
                # Explicit line break
                self.cell(w, h, substr(s, j, i - j), 0, 2, &#34;&#34;, False, link)
                i += 1
                sep = -1
                j = i
                l = 0
                if nl == 1:
                    self.x = self.l_margin
                    w = self.w - self.r_margin - self.x
                    wmax = (w - 2 * self.c_margin) * 1000 / self.font_size
                nl += 1
                continue
            if c == &#34; &#34;:
                sep = i
            if self.unifontsubset:
                l += self.get_string_width(c, True) / self.font_size * 1000
            else:
                l += cw.get(c, 0)
            if l &gt; wmax:
                # Automatic line break
                if sep == -1:
                    if self.x &gt; self.l_margin:
                        # Move to next line
                        self.x = self.l_margin
                        self.y += h
                        w = self.w - self.r_margin - self.x
                        wmax = (w - 2 * self.c_margin) * 1000 / self.font_size
                        i += 1
                        nl += 1
                        continue
                    if i == j:
                        i += 1
                    self.cell(w, h, substr(s, j, i - j), 0, 2, &#34;&#34;, False, link)
                else:
                    self.cell(w, h, substr(s, j, sep - j), 0, 2, &#34;&#34;, False, link)
                    i = sep + 1
                sep = -1
                j = i
                l = 0
                if nl == 1:
                    self.x = self.l_margin
                    w = self.w - self.r_margin - self.x
                    wmax = (w - 2 * self.c_margin) * 1000 / self.font_size
                nl += 1
            else:
                i += 1
        # Last chunk
        if i != j:
            self.cell(l / 1000 * self.font_size, h, substr(s, j), 0, 0, &#34;&#34;, False, link)

    @check_page
    def image(
        self,
        name,
        x=None,
        y=None,
        w=0,
        h=0,
        type=&#34;&#34;,
        link=&#34;&#34;,
    ):
        &#34;&#34;&#34;
        Put an image on the page

        Args:
            name: either a string representing a file path to an image, or a instance of
            `PIL.Image.Image`
            x (int): optional horizontal position where to put the image on the page
            y (int): optional vertical position where to put the image on the page
            w (int): optional width of the image
            h (int): optional height of the image
            type (str): [**DEPRECATED**] unused, will be removed in a later version
            link (str): optional link, internal or external, to add on the image
        &#34;&#34;&#34;
        if type:
            warnings.warn(
                &#39;&#34;type&#34; is unused and will soon be deprecated&#39;,
                PendingDeprecationWarning,
            )
        if isinstance(name, str):
            img = load_resource(name)
        else:
            name, img = uuid4(), name
        if name not in self.images:
            info = get_img_info(img)
            info[&#34;i&#34;] = len(self.images) + 1
            self.images[name] = info
        else:
            info = self.images[name]

        # Automatic width and height calculation if needed
        if w == 0 and h == 0:
            # Put image at 72 dpi
            w = info[&#34;w&#34;] / self.k
            h = info[&#34;h&#34;] / self.k
        elif w == 0:
            w = h * info[&#34;w&#34;] / info[&#34;h&#34;]
        elif h == 0:
            h = w * info[&#34;h&#34;] / info[&#34;w&#34;]

        # Flowing mode
        if y is None:
            self.perform_page_break_if_need_be(h)
            y = self.y
            self.y += h

        if x is None:
            x = self.x
        self._out(
            (
                f&#34;q {w * self.k:.2f} 0 0 {h * self.k:.2f} {x * self.k:.2f} &#34;
                f&#34;{(self.h - y - h) * self.k:.2f} cm /I{info[&#39;i&#39;]} Do Q&#34;
            )
        )
        if link:
            self.link(x, y, w, h, link)

        return info

    @check_page
    def ln(self, h=None):
        &#34;&#34;&#34;
        Line Feed.
        The current abscissa goes back to the left margin and the ordinate increases by
        the amount passed as parameter.

        Args:
            h (int): The height of the break.
                By default, the value equals the height of the last printed cell.
        &#34;&#34;&#34;
        self.x = self.l_margin
        self.y += self.lasth if h is None else h

    def get_x(self):
        &#34;&#34;&#34;Get x position&#34;&#34;&#34;
        return self.x

    def set_x(self, x):
        &#34;&#34;&#34;Set x position&#34;&#34;&#34;
        self.x = x if x &gt;= 0 else self.w + x

    def get_y(self):
        &#34;&#34;&#34;Get y position&#34;&#34;&#34;
        return self.y

    def set_y(self, y):
        &#34;&#34;&#34;Set y position and reset x&#34;&#34;&#34;
        self.x = self.l_margin
        self.y = y if y &gt;= 0 else self.h + y

    def set_xy(self, x, y):
        &#34;&#34;&#34;Set x and y positions&#34;&#34;&#34;
        self.set_y(y)
        self.set_x(x)

    def output(self, name=&#34;&#34;, dest=&#34;&#34;):
        &#34;&#34;&#34;
        Output PDF to some destination.

        By default the bytearray buffer is returned.
        If a `name` is given, the PDF is written to a new file.

        Args:
            name (str): optional File object or file path where to save the PDF under
            dest (str): [**DEPRECATED**] unused, will be removed in a later version
        &#34;&#34;&#34;
        if dest:
            warnings.warn(
                &#39;&#34;dest&#34; is unused and will soon be deprecated&#39;,
                PendingDeprecationWarning,
            )
        # Finish document if necessary:
        if self.state &lt; DocumentState.CLOSED:
            self.close()
        if name:
            if isinstance(name, os.PathLike):
                name.write_bytes(self.buffer)
            elif isinstance(name, str):
                Path(name).write_bytes(self.buffer)
            else:
                name.write(self.buffer)
            return None
        return self.buffer

    def normalize_text(self, txt):
        &#34;&#34;&#34;Check that text input is in the correct format/encoding&#34;&#34;&#34;
        # - for TTF unicode fonts: unicode object (utf8 encoding)
        # - for built-in fonts: string instances (encoding: latin-1, cp1252)
        if not self.unifontsubset and self.core_fonts_encoding:
            return txt.encode(self.core_fonts_encoding).decode(&#34;latin-1&#34;)
        return txt

    def _putpages(self):
        nb = self.page
        if self.str_alias_nb_pages:
            substituted = False
            # Replace number of pages in fonts using subsets (unicode)
            alias = self.str_alias_nb_pages.encode(&#34;UTF-16BE&#34;)
            encoded_nb = str(nb).encode(&#34;UTF-16BE&#34;)
            for n in range(1, nb + 1):
                new_content = self.pages[n][&#34;content&#34;].replace(alias, encoded_nb)
                substituted |= self.pages[n][&#34;content&#34;] != new_content
                self.pages[n][&#34;content&#34;] = new_content
            # Now repeat for no pages in non-subset fonts
            alias = self.str_alias_nb_pages.encode(&#34;latin-1&#34;)
            encoded_nb = str(nb).encode(&#34;latin-1&#34;)
            for n in range(1, nb + 1):
                new_content = self.pages[n][&#34;content&#34;].replace(alias, encoded_nb)
                substituted |= self.pages[n][&#34;content&#34;] != new_content
                self.pages[n][&#34;content&#34;] = new_content
            if substituted:
                LOGGER.info(
                    &#34;Substitution of &#39;%s&#39; was performed in the document&#34;,
                    self.str_alias_nb_pages,
                )
        if self.def_orientation == &#34;P&#34;:
            dw_pt = self.dw_pt
            dh_pt = self.dh_pt
        else:
            dw_pt = self.dh_pt
            dh_pt = self.dw_pt
        filter = &#34;/Filter /FlateDecode &#34; if self.compress else &#34;&#34;
        for n in range(1, nb + 1):
            # page object from pages[n]
            # page object from pages[n]#w_pt
            # page object from pages[n]#h_pt
            # page object from page_links[n] if page_links and page_links[n]
            # Page
            self._newobj()
            self._out(&#34;&lt;&lt;/Type /Page&#34;)
            self._out(&#34;/Parent 1 0 R&#34;)
            w_pt = self.pages[n][&#34;w_pt&#34;]
            h_pt = self.pages[n][&#34;h_pt&#34;]
            if w_pt != dw_pt or h_pt != dh_pt:
                self._out(f&#34;/MediaBox [0 0 {w_pt:.2f} {h_pt:.2f}]&#34;)
            self._out(&#34;/Resources 2 0 R&#34;)

            if self.page_links and n in self.page_links:
                # Links
                annots = &#34;/Annots [&#34;
                for pl in self.page_links[n]:
                    # first four things in &#39;link&#39; list are coordinates?
                    rect = (
                        f&#34;{pl[0]:.2f} {pl[1]:.2f} &#34;
                        f&#34;{pl[0] + pl[2]:.2f} {pl[1] - pl[3]:.2f}&#34;
                    )

                    # start the annotation entry
                    annots += (
                        f&#34;&lt;&lt;/Type /Annot /Subtype /Link &#34;
                        f&#34;/Rect [{rect}] /Border [0 0 0] &#34;
                        # Flag &#34;Print&#34; (bit position 3) specifies to print
                        # the annotation when the page is printed.
                        # cf. https://docs.verapdf.org/validation/pdfa-part1/#rule-653-2
                        f&#34;/F 4&#34;
                    )

                    # HTML ending of annotation entry
                    if isinstance(pl[4], str):
                        annots += f&#34;/A &lt;&lt;/S /URI /URI {enclose_in_parens(pl[4])}&gt;&gt;&gt;&gt;&#34;

                    # Dest type ending of annotation entry
                    else:
                        assert pl[4] in self.links, (
                            f&#34;Page {n} has a link with an invalid index: &#34;
                            f&#34;{pl[4]} (doc #links={len(self.links)})&#34;
                        )
                        l = self.links[pl[4]]
                        # if l[0] in self.orientation_changes: h = w_pt
                        # else:                                h = h_pt
                        annots += (
                            f&#34;/Dest [{1 + 2 * l[0]} 0 R /XYZ 0 &#34;
                            f&#34;{h_pt - l[1] * self.k:.2f} null]&gt;&gt;&#34;
                        )

                # End links list
                self._out(f&#34;{annots}]&#34;)
            if self.pdf_version &gt; &#34;1.3&#34;:
                self._out(&#34;/Group &lt;&lt;/Type /Group /S /Transparency&#34; &#34;/CS /DeviceRGB&gt;&gt;&#34;)
            self._out(f&#34;/Contents {self.n + 1} 0 R&gt;&gt;&#34;)
            self._out(&#34;endobj&#34;)

            # Page content
            content = self.pages[n][&#34;content&#34;]
            p = zlib.compress(content) if self.compress else content
            self._newobj()
            self._out(f&#34;&lt;&lt;{filter}/Length {len(p)}&gt;&gt;&#34;)
            self._out(pdf_stream(p))
            self._out(&#34;endobj&#34;)
        # Pages root
        self.offsets[1] = len(self.buffer)
        self._out(&#34;1 0 obj&#34;)
        self._out(&#34;&lt;&lt;/Type /Pages&#34;)
        kids = &#34;/Kids [&#34;
        for i in range(nb):
            kids += f&#34;{3 + 2 * i} 0 R &#34;
        self._out(kids + &#34;]&#34;)
        self._out(f&#34;/Count {nb}&#34;)
        self._out(f&#34;/MediaBox [0 0 {dw_pt:.2f} {dh_pt:.2f}]&#34;)
        self._out(&#34;&gt;&gt;&#34;)
        self._out(&#34;endobj&#34;)

    def _putfonts(self):
        nf = self.n
        for diff in self.diffs:
            # Encodings
            self._newobj()
            self._out(
                &#34;&lt;&lt;/Type /Encoding /BaseEncoding /WinAnsiEncoding &#34;
                + &#34;/Differences [&#34;
                + self.diffs[diff]
                + &#34;]&gt;&gt;&#34;
            )
            self._out(&#34;endobj&#34;)

        for name, info in self.font_files.items():
            if &#34;type&#34; in info and info[&#34;type&#34;] != &#34;TTF&#34;:
                # Font file embedding
                self._newobj()
                self.font_files[name][&#34;n&#34;] = self.n
                font = (FPDF_FONT_DIR / name).read_bytes()
                compressed = substr(name, -2) == &#34;.z&#34;
                if not compressed and &#34;length2&#34; in info:
                    header = ord(font[0]) == 128
                    if header:
                        # Strip first binary header
                        font = substr(font, 6)
                    if header and ord(font[info[&#34;length1&#34;]]) == 128:
                        # Strip second binary header
                        font = substr(font, 0, info[&#34;length1&#34;]) + substr(
                            font, info[&#34;length1&#34;] + 6
                        )

                self._out(f&#34;&lt;&lt;/Length {len(font)}&#34;)
                if compressed:
                    self._out(&#34;/Filter /FlateDecode&#34;)
                self._out(f&#34;/Length1 {info[&#39;length1&#39;]}&#34;)
                if &#34;length2&#34; in info:
                    self._out(f&#34;/Length2 {info[&#39;length2&#39;]} /Length3 0&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(pdf_stream(font))
                self._out(&#34;endobj&#34;)

        # Font objects
        flist = [(x[1][&#34;i&#34;], x[0], x[1]) for x in self.fonts.items()]
        flist.sort()
        for _, font_name, font in flist:
            self.fonts[font_name][&#34;n&#34;] = self.n + 1
            my_type = font[&#34;type&#34;]
            name = font[&#34;name&#34;]
            # Standard font
            if my_type == &#34;core&#34;:
                self._newobj()
                self._out(&#34;&lt;&lt;/Type /Font&#34;)
                self._out(f&#34;/BaseFont /{name}&#34;)
                self._out(&#34;/Subtype /Type1&#34;)
                if name not in (&#34;Symbol&#34;, &#34;ZapfDingbats&#34;):
                    self._out(&#34;/Encoding /WinAnsiEncoding&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

            # Additional Type1 or TrueType font
            elif my_type in (&#34;Type1&#34;, &#34;TrueType&#34;):
                self._newobj()
                self._out(&#34;&lt;&lt;/Type /Font&#34;)
                self._out(f&#34;/BaseFont /{name}&#34;)
                self._out(f&#34;/Subtype /{my_type}&#34;)
                self._out(&#34;/FirstChar 32 /LastChar 255&#34;)
                self._out(f&#34;/Widths {self.n + 1} 0 R&#34;)
                self._out(f&#34;/FontDescriptor {self.n + 2} 0 R&#34;)
                if font[&#34;enc&#34;]:
                    if &#34;diff&#34; in font:
                        self._out(f&#34;/Encoding {nf + font[&#39;diff&#39;]} 0 R&#34;)
                    else:
                        self._out(&#34;/Encoding /WinAnsiEncoding&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

                # Widths
                self._newobj()
                cw = font[&#34;cw&#34;]
                s = &#34;[&#34;
                for i in range(32, 256):
                    # Get doesn&#39;t raise exception;
                    # returns 0 instead of None if not set
                    s += f&#34;{cw.get(chr(i), 0)} &#34;
                self._out(f&#34;{s}]&#34;)
                self._out(&#34;endobj&#34;)

                # Descriptor
                self._newobj()
                s = f&#34;&lt;&lt;/Type /FontDescriptor /FontName /{name}&#34;
                for k in (
                    &#34;Ascent&#34;,
                    &#34;Descent&#34;,
                    &#34;CapHeight&#34;,
                    &#34;Flags&#34;,
                    &#34;FontBBox&#34;,
                    &#34;ItalicAngle&#34;,
                    &#34;StemV&#34;,
                    &#34;MissingWidth&#34;,
                ):
                    s += f&#34; /{k} {font[&#39;desc&#39;][k]}&#34;

                filename = font[&#34;file&#34;]
                if filename:
                    s += &#34; /FontFile&#34;
                    if my_type != &#34;Type1&#34;:
                        s += &#34;2&#34;
                    s += f&#34; {self.font_files[filename][&#39;n&#39;]} 0 R&#34;
                self._out(f&#34;{s}&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)
            elif my_type == &#34;TTF&#34;:
                self.fonts[font_name][&#34;n&#34;] = self.n + 1
                ttf = TTFontFile()
                fontname = f&#34;MPDFAA+{font[&#39;name&#39;]}&#34;
                subset = font[&#34;subset&#34;]
                del subset[0]
                ttfontstream = ttf.makeSubset(font[&#34;ttffile&#34;], subset)
                ttfontsize = len(ttfontstream)
                fontstream = zlib.compress(ttfontstream)
                codeToGlyph = ttf.codeToGlyph
                # del codeToGlyph[0]

                # Type0 Font
                # A composite font - a font composed of other fonts,
                # organized hierarchically
                self._newobj()
                self._out(&#34;&lt;&lt;/Type /Font&#34;)
                self._out(&#34;/Subtype /Type0&#34;)
                self._out(f&#34;/BaseFont /{fontname}&#34;)
                self._out(&#34;/Encoding /Identity-H&#34;)
                self._out(f&#34;/DescendantFonts [{self.n + 1} 0 R]&#34;)
                self._out(f&#34;/ToUnicode {self.n + 2} 0 R&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

                # CIDFontType2
                # A CIDFont whose glyph descriptions are based on
                # TrueType font technology
                self._newobj()
                self._out(&#34;&lt;&lt;/Type /Font&#34;)
                self._out(&#34;/Subtype /CIDFontType2&#34;)
                self._out(f&#34;/BaseFont /{fontname}&#34;)
                self._out(f&#34;/CIDSystemInfo {self.n + 2} 0 R&#34;)
                self._out(f&#34;/FontDescriptor {self.n + 3} 0 R&#34;)
                if font[&#34;desc&#34;].get(&#34;MissingWidth&#34;):
                    self._out(f&#34;/DW {font[&#39;desc&#39;][&#39;MissingWidth&#39;]}&#34;)
                self._putTTfontwidths(font, ttf.maxUni)
                self._out(f&#34;/CIDToGIDMap {self.n + 4} 0 R&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

                # ToUnicode
                self._newobj()
                toUni = (
                    &#34;/CIDInit /ProcSet findresource begin\n&#34;
                    &#34;12 dict begin\n&#34;
                    &#34;begincmap\n&#34;
                    &#34;/CIDSystemInfo\n&#34;
                    &#34;&lt;&lt;/Registry (Adobe)\n&#34;
                    &#34;/Ordering (UCS)\n&#34;
                    &#34;/Supplement 0\n&#34;
                    &#34;&gt;&gt; def\n&#34;
                    &#34;/CMapName /Adobe-Identity-UCS def\n&#34;
                    &#34;/CMapType 2 def\n&#34;
                    &#34;1 begincodespacerange\n&#34;
                    &#34;&lt;0000&gt; &lt;FFFF&gt;\n&#34;
                    &#34;endcodespacerange\n&#34;
                    &#34;1 beginbfrange\n&#34;
                    &#34;&lt;0000&gt; &lt;FFFF&gt; &lt;0000&gt;\n&#34;
                    &#34;endbfrange\n&#34;
                    &#34;endcmap\n&#34;
                    &#34;CMapName currentdict /CMap defineresource pop\n&#34;
                    &#34;end\n&#34;
                    &#34;end&#34;
                )
                self._out(f&#34;&lt;&lt;/Length {len(toUni)}&gt;&gt;&#34;)
                self._out(pdf_stream(toUni))
                self._out(&#34;endobj&#34;)

                # CIDSystemInfo dictionary
                self._newobj()
                self._out(&#34;&lt;&lt;/Registry (Adobe)&#34;)
                self._out(&#34;/Ordering (UCS)&#34;)
                self._out(&#34;/Supplement 0&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

                # Font descriptor
                self._newobj()
                self._out(&#34;&lt;&lt;/Type /FontDescriptor&#34;)
                self._out(&#34;/FontName /&#34; + fontname)
                for kd in (
                    &#34;Ascent&#34;,
                    &#34;Descent&#34;,
                    &#34;CapHeight&#34;,
                    &#34;Flags&#34;,
                    &#34;FontBBox&#34;,
                    &#34;ItalicAngle&#34;,
                    &#34;StemV&#34;,
                    &#34;MissingWidth&#34;,
                ):
                    v = font[&#34;desc&#34;][kd]
                    if kd == &#34;Flags&#34;:
                        v = v | 4
                        v = v &amp; ~32  # SYMBOLIC font flag
                    self._out(f&#34; /{kd} {v}&#34;)
                self._out(f&#34;/FontFile2 {self.n + 2} 0 R&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

                # Embed CIDToGIDMap
                # A specification of the mapping from CIDs to glyph indices
                cidtogidmap = [&#34;\x00&#34;] * 256 * 256 * 2
                for cc, glyph in codeToGlyph.items():
                    cidtogidmap[cc * 2] = chr(glyph &gt;&gt; 8)
                    cidtogidmap[cc * 2 + 1] = chr(glyph &amp; 0xFF)
                cidtogidmap = &#34;&#34;.join(cidtogidmap)
                # manage binary data as latin1 until PEP461-like function is implemented
                cidtogidmap = zlib.compress(cidtogidmap.encode(&#34;latin1&#34;))
                self._newobj()
                self._out(f&#34;&lt;&lt;/Length {len(cidtogidmap)}&#34;)
                self._out(&#34;/Filter /FlateDecode&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(pdf_stream(cidtogidmap))
                self._out(&#34;endobj&#34;)

                # Font file
                self._newobj()
                self._out(f&#34;&lt;&lt;/Length {len(fontstream)}&#34;)
                self._out(&#34;/Filter /FlateDecode&#34;)
                self._out(f&#34;/Length1 {ttfontsize}&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(pdf_stream(fontstream))
                self._out(&#34;endobj&#34;)
                del ttf
            else:
                # Allow for additional types
                mtd = f&#34;_put{my_type.lower()}&#34;
                # check if self has a attr mtd which is callable (method)
                if not callable(getattr(self, mtd, None)):
                    raise FPDFException(f&#34;Unsupported font type: {my_type}&#34;)
                # pylint: disable=no-member
                self.mtd(font)

    def _putTTfontwidths(self, font, maxUni):
        if font[&#34;unifilename&#34;]:
            cw127fname = Path(font[&#34;unifilename&#34;]).with_suffix(&#34;.cw127.pkl&#34;)
        else:
            cw127fname = None
        font_dict = load_cache(cw127fname)
        if font_dict is None:
            rangeid = 0
            range_ = {}
            range_interval = {}
            prevcid = -2
            prevwidth = -1
            interval = False
            startcid = 1
        else:
            rangeid = font_dict[&#34;rangeid&#34;]
            range_ = font_dict[&#34;range&#34;]
            prevcid = font_dict[&#34;prevcid&#34;]
            prevwidth = font_dict[&#34;prevwidth&#34;]
            interval = font_dict[&#34;interval&#34;]
            range_interval = font_dict[&#34;range_interval&#34;]
            startcid = 128
        cwlen = maxUni + 1

        # for each character
        subset = set(font[&#34;subset&#34;])
        for cid in range(startcid, cwlen):
            if cid == 128 and cw127fname and not cw127fname.exists():
                try:
                    font_dict = {
                        &#34;rangeid&#34;: rangeid,
                        &#34;prevcid&#34;: prevcid,
                        &#34;prevwidth&#34;: prevwidth,
                        &#34;interval&#34;: interval,
                        &#34;range_interval&#34;: range_interval,
                        &#34;range&#34;: range_,
                    }
                    with cw127fname.open(&#34;wb&#34;) as fh:
                        pickle.dump(font_dict, fh)
                except OSError as e:
                    if e.errno != errno.EACCES:
                        raise  # Not a permission error.

            if cid &gt; 255 and (cid not in subset or cid &gt;= len(font[&#34;cw&#34;])):
                continue
            width = font[&#34;cw&#34;][cid]
            if width == 0:
                continue
            if width == 65535:
                width = 0

            if &#34;dw&#34; not in font or (font[&#34;dw&#34;] and width != font[&#34;dw&#34;]):
                if cid == (prevcid + 1):
                    if width == prevwidth:
                        if width == range_[rangeid][0]:
                            range_.setdefault(rangeid, []).append(width)
                        else:
                            range_[rangeid].pop()
                            # new range
                            rangeid = prevcid
                            range_[rangeid] = [prevwidth, width]
                        interval = True
                        range_interval[rangeid] = True
                    else:
                        if interval:
                            # new range
                            rangeid = cid
                            range_[rangeid] = [width]
                        else:
                            range_[rangeid].append(width)
                        interval = False
                else:
                    rangeid = cid
                    range_[rangeid] = [width]
                    interval = False
                prevcid = cid
                prevwidth = width
        prevk = -1
        nextk = -1
        prevint = False

        ri = range_interval
        for k, ws in sorted(range_.items()):
            cws = len(ws)
            if k == nextk and not prevint and (k not in ri or cws &lt; 3):
                if k in ri:
                    del ri[k]
                range_[prevk] = range_[prevk] + range_[k]
                del range_[k]
            else:
                prevk = k
            nextk = k + cws
            if k in ri:
                prevint = cws &gt; 3
                del ri[k]
                nextk -= 1
            else:
                prevint = False
        w = []
        for k, ws in sorted(range_.items()):
            if len(set(ws)) == 1:
                w.append(f&#34; {k} {k + len(ws) - 1} {ws[0]}&#34;)
            else:
                w.append(f&#34; {k} [ {&#39; &#39;.join(str(int(h)) for h in ws)} ]\n&#34;)
        self._out(f&#34;/W [{&#39;&#39;.join(w)}]&#34;)

    def _putimages(self):
        i = [(x[1][&#34;i&#34;], x[1]) for x in self.images.items()]
        i.sort()
        for _, info in i:
            self._putimage(info)
            del info[&#34;data&#34;]
            if &#34;smask&#34; in info:
                del info[&#34;smask&#34;]

    def _putimage(self, info):
        if &#34;data&#34; not in info:
            return
        self._newobj()
        info[&#34;n&#34;] = self.n
        self._out(&#34;&lt;&lt;/Type /XObject&#34;)
        self._out(&#34;/Subtype /Image&#34;)
        self._out(f&#34;/Width {info[&#39;w&#39;]}&#34;)
        self._out(f&#34;/Height {info[&#39;h&#39;]}&#34;)

        if info[&#34;cs&#34;] == &#34;Indexed&#34;:
            self._out(
                f&#34;/ColorSpace [/Indexed /DeviceRGB &#34;
                f&#34;{len(info[&#39;pal&#39;]) // 3 - 1} {self.n + 1} 0 R]&#34;
            )
        else:
            self._out(f&#34;/ColorSpace /{info[&#39;cs&#39;]}&#34;)
            if info[&#34;cs&#34;] == &#34;DeviceCMYK&#34;:
                self._out(&#34;/Decode [1 0 1 0 1 0 1 0]&#34;)

        self._out(f&#34;/BitsPerComponent {info[&#39;bpc&#39;]}&#34;)

        if &#34;f&#34; in info:
            self._out(f&#34;/Filter /{info[&#39;f&#39;]}&#34;)
        if &#34;dp&#34; in info:
            self._out(f&#34;/DecodeParms &lt;&lt;{info[&#39;dp&#39;]}&gt;&gt;&#34;)

        if &#34;trns&#34; in info and isinstance(info[&#34;trns&#34;], list):
            trns = &#34; &#34;.join(f&#34;{x} {x}&#34; for x in info[&#34;trns&#34;])
            self._out(f&#34;/Mask [{trns}]&#34;)

        if &#34;smask&#34; in info:
            self._out(f&#34;/SMask {self.n + 1} 0 R&#34;)

        self._out(f&#34;/Length {len(info[&#39;data&#39;])}&gt;&gt;&#34;)
        self._out(pdf_stream(info[&#34;data&#34;]))
        self._out(&#34;endobj&#34;)

        # Soft mask
        if &#34;smask&#34; in info:
            dp = f&#34;/Predictor 15 /Colors 1 /BitsPerComponent 8 /Columns {info[&#39;w&#39;]}&#34;
            smask = {
                &#34;w&#34;: info[&#34;w&#34;],
                &#34;h&#34;: info[&#34;h&#34;],
                &#34;cs&#34;: &#34;DeviceGray&#34;,
                &#34;bpc&#34;: 8,
                &#34;f&#34;: info[&#34;f&#34;],
                &#34;dp&#34;: dp,
                &#34;data&#34;: info[&#34;smask&#34;],
            }
            self._putimage(smask)

        # Palette
        if info[&#34;cs&#34;] == &#34;Indexed&#34;:
            self._newobj()
            filter, pal = (
                (&#34;/Filter /FlateDecode &#34;, zlib.compress(info[&#34;pal&#34;]))
                if self.compress
                else (&#34;&#34;, info[&#34;pal&#34;])
            )
            self._out(f&#34;&lt;&lt;{filter}/Length {len(pal)}&gt;&gt;&#34;)
            self._out(pdf_stream(pal))
            self._out(&#34;endobj&#34;)

    def _putxobjectdict(self):
        i = [(x[&#34;i&#34;], x[&#34;n&#34;]) for x in self.images.values()]
        i.sort()
        for idx, n in i:
            self._out(f&#34;/I{idx} {n} 0 R&#34;)

    def _putresourcedict(self):
        # From section 10.1, &#34;Procedure Sets&#34;, of PDF 1.7 spec:
        # &gt; Beginning with PDF 1.4, this feature is considered obsolete.
        # &gt; For compatibility with existing consumer applications,
        # &gt; PDF producer applications should continue to specify procedure sets
        # &gt; (preferably, all of those listed in Table 10.1).
        self._out(&#34;/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]&#34;)
        self._out(&#34;/Font &lt;&lt;&#34;)
        f = [(x[&#34;i&#34;], x[&#34;n&#34;]) for x in self.fonts.values()]
        f.sort()
        for idx, n in f:
            self._out(f&#34;/F{idx} {pdf_ref(n)}&#34;)
        self._out(&#34;&gt;&gt;&#34;)
        self._out(&#34;/XObject &lt;&lt;&#34;)
        self._putxobjectdict()
        self._out(&#34;&gt;&gt;&#34;)

    def _putresources(self):
        with self._trace_size(&#34;resources.fonts&#34;):
            self._putfonts()
        with self._trace_size(&#34;resources.images&#34;):
            self._putimages()

        # Resource dictionary
        with self._trace_size(&#34;resources.dict&#34;):
            self.offsets[2] = len(self.buffer)
            self._out(&#34;2 0 obj&#34;)
            self._out(&#34;&lt;&lt;&#34;)
            self._putresourcedict()
            self._out(&#34;&gt;&gt;&#34;)
            self._out(&#34;endobj&#34;)

    def _putinfo(self):
        info_d = {
            pdf_name(&#34;title&#34;): enclose_in_parens(getattr(self, &#34;title&#34;, None)),
            pdf_name(&#34;subject&#34;): enclose_in_parens(getattr(self, &#34;subject&#34;, None)),
            pdf_name(&#34;author&#34;): enclose_in_parens(getattr(self, &#34;author&#34;, None)),
            pdf_name(&#34;keywords&#34;): enclose_in_parens(getattr(self, &#34;keywords&#34;, None)),
            pdf_name(&#34;creator&#34;): enclose_in_parens(getattr(self, &#34;creator&#34;, None)),
        }

        if hasattr(self, &#34;creation_date&#34;):
            try:
                creation_date = self.creation_date
                date_string = f&#34;{creation_date:%Y%m%d%H%M%S}&#34;
            except Exception as error:
                raise FPDFException(
                    f&#34;Could not format date: {creation_date}&#34;
                ) from error
        else:
            date_string = f&#34;{datetime.now():%Y%m%d%H%M%S}&#34;
        info_d[pdf_name(&#34;CreationDate&#34;)] = enclose_in_parens(f&#34;D:{date_string}&#34;)

        self._out(pdf_d(info_d, open_dict=&#34;&#34;, close_dict=&#34;&#34;, has_empty_fields=True))

    def _putcatalog(self):
        catalog_d = {
            pdf_name(&#34;type&#34;): pdf_name(&#34;catalog&#34;),
            pdf_name(&#34;pages&#34;): pdf_ref(1),
        }

        zoom_configs = {
            &#34;default&#34;: [&#34;/Fit&#34;],  # TODO FIXME
            &#34;fullpage&#34;: [&#34;/Fit&#34;],
            &#34;fullwidth&#34;: [&#34;/FitH&#34;, &#34;null&#34;],
            &#34;real&#34;: [&#34;/XYZ&#34;, &#34;null&#34;, &#34;null&#34;, &#34;1&#34;],
        }
        zoom_config = [pdf_ref(3), *zoom_configs.get(self.zoom_mode, [])]
        # zoom_config is a number, not one of the allowed strings
        if not zoom_config:
            zoom_config = [&#34;/XYZ&#34;, &#34;null&#34;, &#34;null&#34;, str(self.zoom_mode / 100)]

        catalog_d[pdf_name(&#34;OpenAction&#34;)] = pdf_l(zoom_config)

        layout_names = {
            &#34;single&#34;: pdf_name(&#34;SinglePage&#34;),
            &#34;continuous&#34;: pdf_name(&#34;OneColumn&#34;),
            &#34;two&#34;: pdf_name(&#34;TwoColumnLeft&#34;),
        }

        if self.layout_mode in layout_names:
            catalog_d[pdf_name(&#34;PageLayout&#34;)] = layout_names[self.layout_mode]

        self._out(pdf_d(catalog_d, open_dict=&#34;&#34;, close_dict=&#34;&#34;))

    def _putheader(self):
        self._out(f&#34;%PDF-{self.pdf_version}&#34;)

    def _puttrailer(self):
        self._out(f&#34;/Size {self.n + 1}&#34;)
        self._out(f&#34;/Root {pdf_ref(self.n)}&#34;)
        self._out(f&#34;/Info {pdf_ref(self.n - 1)}&#34;)

    def _enddoc(self):
        LOGGER.debug(&#34;Final doc sections size summary:&#34;)
        with self._trace_size(&#34;header&#34;):
            self._putheader()
        with self._trace_size(&#34;pages&#34;):
            self._putpages()
        self._putresources()  # trace_size is performed inside
        # Info
        with self._trace_size(&#34;info&#34;):
            self._newobj()
            self._out(&#34;&lt;&lt;&#34;)
            self._putinfo()
            self._out(&#34;&gt;&gt;&#34;)
            self._out(&#34;endobj&#34;)
        # Catalog
        with self._trace_size(&#34;catalog&#34;):
            self._newobj()
            self._out(&#34;&lt;&lt;&#34;)
            self._putcatalog()
            self._out(&#34;&gt;&gt;&#34;)
            self._out(&#34;endobj&#34;)
        # Cross-ref
        with self._trace_size(&#34;xref&#34;):
            o = len(self.buffer)
            self._out(&#34;xref&#34;)
            self._out(f&#34;0 {self.n + 1}&#34;)
            self._out(&#34;0000000000 65535 f &#34;)
            for i in range(1, self.n + 1):
                self._out(f&#34;{self.offsets[i]:010} 00000 n &#34;)
        # Trailer
        with self._trace_size(&#34;trailer&#34;):
            self._out(&#34;trailer&#34;)
            self._out(&#34;&lt;&lt;&#34;)
            self._puttrailer()
            self._out(&#34;&gt;&gt;&#34;)
            self._out(&#34;startxref&#34;)
            self._out(o)
        self._out(&#34;%%EOF&#34;)
        self.state = DocumentState.CLOSED

    def _beginpage(self, orientation, format, same):
        self.page += 1
        self.pages[self.page] = {&#34;content&#34;: bytearray()}
        self.state = DocumentState.GENERATING_PAGE
        self.x = self.l_margin
        self.y = self.t_margin
        self.font_family = &#34;&#34;
        self.font_stretching = 100
        if not same:
            # Page format
            if format:
                # Change page format
                fw_pt, fh_pt = get_page_format(format, self.k)
            else:
                # Set to default format
                fw_pt = self.dw_pt
                fh_pt = self.dh_pt
            # Page orientation
            orientation = (
                orientation[0].upper() if orientation else self.def_orientation
            )
            if orientation == &#34;P&#34;:
                self.w_pt = fw_pt
                self.h_pt = fh_pt
            else:
                self.w_pt = fh_pt
                self.h_pt = fw_pt
            self.w = self.w_pt / self.k
            self.h = self.h_pt / self.k
            self.page_break_trigger = self.h - self.b_margin
            self.cur_orientation = orientation
        self.pages[self.page][&#34;w_pt&#34;] = self.w_pt
        self.pages[self.page][&#34;h_pt&#34;] = self.h_pt

    def _endpage(self):
        # End of page contents
        self.state = DocumentState.READY

    def _newobj(self):
        # Begin a new object
        self.n += 1
        self.offsets[self.n] = len(self.buffer)
        self._out(f&#34;{self.n} 0 obj&#34;)

    def _dounderline(self, x, y, txt):
        # Underline text
        up = self.current_font[&#34;up&#34;]
        ut = self.current_font[&#34;ut&#34;]
        w = self.get_string_width(txt, True) + self.ws * txt.count(&#34; &#34;)
        return (
            f&#34;{x * self.k:.2f} &#34;
            f&#34;{(self.h - y + up / 1000 * self.font_size) * self.k:.2f} &#34;
            f&#34;{w * self.k:.2f} {-ut / 1000 * self.font_size_pt:.2f} re f&#34;
        )

    def _out(self, s):
        if self.state == DocumentState.CLOSED:
            raise FPDFException(
                &#34;Content cannot be added on a closed document, after calling output()&#34;
            )
        if not isinstance(s, bytes):
            if not isinstance(s, str):
                s = str(s)
            s = s.encode(&#34;latin1&#34;)
        if self.state == DocumentState.GENERATING_PAGE:
            self.pages[self.page][&#34;content&#34;] += s + b&#34;\n&#34;
        else:
            self.buffer += s + b&#34;\n&#34;

    @check_page
    def interleaved2of5(self, txt, x, y, w=1, h=10):
        &#34;&#34;&#34;Barcode I2of5 (numeric), adds a 0 if odd length&#34;&#34;&#34;
        narrow = w / 3
        wide = w

        # wide/narrow codes for the digits
        bar_char = {
            &#34;0&#34;: &#34;nnwwn&#34;,
            &#34;1&#34;: &#34;wnnnw&#34;,
            &#34;2&#34;: &#34;nwnnw&#34;,
            &#34;3&#34;: &#34;wwnnn&#34;,
            &#34;4&#34;: &#34;nnwnw&#34;,
            &#34;5&#34;: &#34;wnwnn&#34;,
            &#34;6&#34;: &#34;nwwnn&#34;,
            &#34;7&#34;: &#34;nnnww&#34;,
            &#34;8&#34;: &#34;wnnwn&#34;,
            &#34;9&#34;: &#34;nwnwn&#34;,
            &#34;A&#34;: &#34;nn&#34;,
            &#34;Z&#34;: &#34;wn&#34;,
        }

        self.set_fill_color(0)
        code = txt
        # add leading zero if code-length is odd
        if len(code) % 2 != 0:
            code = f&#34;0{code}&#34;

        # add start and stop codes
        code = f&#34;AA{code.lower()}ZA&#34;

        for i in range(0, len(code), 2):
            # choose next pair of digits
            char_bar = code[i]
            char_space = code[i + 1]
            # check whether it is a valid digit
            if char_bar not in bar_char:
                raise RuntimeError(f&#39;Char &#34;{char_bar}&#34; invalid for I25:&#39;)
            if char_space not in bar_char:
                raise RuntimeError(f&#39;Char &#34;{char_space}&#34; invalid for I25: &#39;)

            # create a wide/narrow-seq (first digit=bars, second digit=spaces)
            seq = &#34;&#34;.join(
                f&#34;{cb}{cs}&#34; for cb, cs in zip(bar_char[char_bar], bar_char[char_space])
            )

            for bar, char in enumerate(seq):
                # set line_width depending on value
                line_width = narrow if char == &#34;n&#34; else wide

                # draw every second value, the other is represented by space
                if bar % 2 == 0:
                    self.rect(x, y, line_width, h, &#34;F&#34;)

                x += line_width

    @check_page
    def code39(self, txt, x, y, w=1.5, h=5):
        &#34;&#34;&#34;Barcode 3of9&#34;&#34;&#34;
        dim = {&#34;w&#34;: w, &#34;n&#34;: w / 3}
        chars = {
            &#34;0&#34;: &#34;nnnwwnwnn&#34;,
            &#34;1&#34;: &#34;wnnwnnnnw&#34;,
            &#34;2&#34;: &#34;nnwwnnnnw&#34;,
            &#34;3&#34;: &#34;wnwwnnnnn&#34;,
            &#34;4&#34;: &#34;nnnwwnnnw&#34;,
            &#34;5&#34;: &#34;wnnwwnnnn&#34;,
            &#34;6&#34;: &#34;nnwwwnnnn&#34;,
            &#34;7&#34;: &#34;nnnwnnwnw&#34;,
            &#34;8&#34;: &#34;wnnwnnwnn&#34;,
            &#34;9&#34;: &#34;nnwwnnwnn&#34;,
            &#34;A&#34;: &#34;wnnnnwnnw&#34;,
            &#34;B&#34;: &#34;nnwnnwnnw&#34;,
            &#34;C&#34;: &#34;wnwnnwnnn&#34;,
            &#34;D&#34;: &#34;nnnnwwnnw&#34;,
            &#34;E&#34;: &#34;wnnnwwnnn&#34;,
            &#34;F&#34;: &#34;nnwnwwnnn&#34;,
            &#34;G&#34;: &#34;nnnnnwwnw&#34;,
            &#34;H&#34;: &#34;wnnnnwwnn&#34;,
            &#34;I&#34;: &#34;nnwnnwwnn&#34;,
            &#34;J&#34;: &#34;nnnnwwwnn&#34;,
            &#34;K&#34;: &#34;wnnnnnnww&#34;,
            &#34;L&#34;: &#34;nnwnnnnww&#34;,
            &#34;M&#34;: &#34;wnwnnnnwn&#34;,
            &#34;N&#34;: &#34;nnnnwnnww&#34;,
            &#34;O&#34;: &#34;wnnnwnnwn&#34;,
            &#34;P&#34;: &#34;nnwnwnnwn&#34;,
            &#34;Q&#34;: &#34;nnnnnnwww&#34;,
            &#34;R&#34;: &#34;wnnnnnwwn&#34;,
            &#34;S&#34;: &#34;nnwnnnwwn&#34;,
            &#34;T&#34;: &#34;nnnnwnwwn&#34;,
            &#34;U&#34;: &#34;wwnnnnnnw&#34;,
            &#34;V&#34;: &#34;nwwnnnnnw&#34;,
            &#34;W&#34;: &#34;wwwnnnnnn&#34;,
            &#34;X&#34;: &#34;nwnnwnnnw&#34;,
            &#34;Y&#34;: &#34;wwnnwnnnn&#34;,
            &#34;Z&#34;: &#34;nwwnwnnnn&#34;,
            &#34;-&#34;: &#34;nwnnnnwnw&#34;,
            &#34;.&#34;: &#34;wwnnnnwnn&#34;,
            &#34; &#34;: &#34;nwwnnnwnn&#34;,
            &#34;*&#34;: &#34;nwnnwnwnn&#34;,
            &#34;$&#34;: &#34;nwnwnwnnn&#34;,
            &#34;/&#34;: &#34;nwnwnnnwn&#34;,
            &#34;+&#34;: &#34;nwnnnwnwn&#34;,
            &#34;%&#34;: &#34;nnnwnwnwn&#34;,
        }
        self.set_fill_color(0)
        for c in txt.upper():
            if c not in chars:
                raise RuntimeError(f&#39;Invalid char &#34;{c}&#34; for Code39&#39;)
            for i, d in enumerate(chars[c]):
                if i % 2 == 0:
                    self.rect(x, y, dim[d], h, &#34;F&#34;)
                x += dim[d]
            x += dim[&#34;n&#34;]

    @check_page
    @contextmanager
    def rect_clip(self, x, y, w, h):
        self._out(
            (
                f&#34;q {x * self.k:.2f} {(self.h - y - h) * self.k:.2f} {w * self.k:.2f} &#34;
                f&#34;{h * self.k:.2f} re W n\n&#34;
            )
        )
        yield
        self._out(&#34;Q\n&#34;)

    @contextmanager
    def _trace_size(self, label):
        prev_size = len(self.buffer)
        yield
        LOGGER.debug(&#34;- %s.size: %s&#34;, label, _sizeof_fmt(len(self.buffer) - prev_size))

    @contextmanager
    def unbreakable(self):
        &#34;&#34;&#34;
        Ensures that all rendering performed in this context appear on a single page
        by performing page break beforehand if need be.

        Note that using this method means to duplicate the FPDF `bytearray` buffer:
        when generating large PDFs, doubling memory usage may be troublesome.
        &#34;&#34;&#34;
        prev_page, prev_y = self.page, self.y
        recorder = FPDFRecorder(self, accept_page_break=False)
        yield recorder
        y_scroll = recorder.y - prev_y + (recorder.page - prev_page) * self.eph
        if prev_y + y_scroll &gt; self.page_break_trigger:
            LOGGER.debug(&#34;Performing page jump due to unbreakable height&#34;)
            recorder.rewind()
            assert recorder.perform_page_break_if_need_be(y_scroll)
            recorder.replay()</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.FPDF.accept_page_break"><code class="name">var <span class="ident">accept_page_break</span></code></dt>
<dd>
<div class="desc"><p>Accept automatic page break or not</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def accept_page_break(self):
    &#34;&#34;&#34;Accept automatic page break or not&#34;&#34;&#34;
    return self.auto_page_break</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.eph"><code class="name">var <span class="ident">eph</span></code></dt>
<dd>
<div class="desc"><p>Effective page height: the page height minus its vertical margins.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def eph(self):
    &#34;&#34;&#34;
    Effective page height: the page height minus its vertical margins.
    &#34;&#34;&#34;
    return self.h - self.t_margin - self.b_margin</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.epw"><code class="name">var <span class="ident">epw</span></code></dt>
<dd>
<div class="desc"><p>Effective page width: the page width minus its horizontal margins.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def epw(self):
    &#34;&#34;&#34;
    Effective page width: the page width minus its horizontal margins.
    &#34;&#34;&#34;
    return self.w - self.l_margin - self.r_margin</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.FPDF.add_font"><code class="name flex">
<span>def <span class="ident">add_font</span></span>(<span>self, family, style='', fname=None, uni=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a TrueType or Type1 font</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_font(self, family, style=&#34;&#34;, fname=None, uni=False):
    &#34;&#34;&#34;Add a TrueType or Type1 font&#34;&#34;&#34;
    if not fname:
        fname = family.replace(&#34; &#34;, &#34;&#34;) + f&#34;{style.lower()}.pkl&#34;
    style = &#34;&#34;.join(sorted(style.upper()))
    if any(letter not in &#34;BI&#34; for letter in style):
        raise ValueError(
            f&#34;Unknown style provided (only B &amp; I letters are allowed): {style}&#34;
        )
    fontkey = f&#34;{family}{style}&#34;

    # Font already added!
    if fontkey in self.fonts:
        return
    if uni:
        for parent in (&#34;.&#34;, FPDF_FONT_DIR, SYSTEM_TTFONTS):
            if (Path(parent) / fname).exists():
                ttffilename = Path(parent) / fname
                break
        else:
            raise RuntimeError(f&#34;TTF Font file not found: {fname}&#34;)
        if FPDF_CACHE_MODE == 0:
            unifilename = Path() / f&#34;{ttffilename.stem}.pkl&#34;
        elif FPDF_CACHE_MODE == 2:
            unifilename = FPDF_CACHE_DIR / f&#34;{_hashpath(ttffilename)}.pkl&#34;
        else:
            unifilename = None

        font_dict = load_cache(unifilename)
        if font_dict is None:
            ttf = TTFontFile()
            ttf.getMetrics(ttffilename)
            desc = {
                &#34;Ascent&#34;: round(ttf.ascent),
                &#34;Descent&#34;: round(ttf.descent),
                &#34;CapHeight&#34;: round(ttf.capHeight),
                &#34;Flags&#34;: ttf.flags,
                &#34;FontBBox&#34;: (
                    f&#34;[{ttf.bbox[0]:.0f} {ttf.bbox[1]:.0f}&#34;
                    f&#34; {ttf.bbox[2]:.0f} {ttf.bbox[3]:.0f}]&#34;
                ),
                &#34;ItalicAngle&#34;: int(ttf.italicAngle),
                &#34;StemV&#34;: round(ttf.stemV),
                &#34;MissingWidth&#34;: round(ttf.defaultWidth),
            }

            # Generate metrics .pkl file
            font_dict = {
                &#34;name&#34;: re.sub(&#34;[ ()]&#34;, &#34;&#34;, ttf.fullName),
                &#34;type&#34;: &#34;TTF&#34;,
                &#34;desc&#34;: desc,
                &#34;up&#34;: round(ttf.underlinePosition),
                &#34;ut&#34;: round(ttf.underlineThickness),
                &#34;ttffile&#34;: ttffilename,
                &#34;fontkey&#34;: fontkey,
                &#34;originalsize&#34;: os.stat(ttffilename).st_size,
                &#34;cw&#34;: ttf.charWidths,
            }

            if unifilename:
                try:
                    unifilename.write_bytes(pickle.dumps(font_dict))
                except OSError as e:
                    if e.errno != errno.EACCES:
                        raise  # Not a permission error.
            del ttf

        # include numbers in the subset! (if alias present)
        sbarr = list(range(57 if self.str_alias_nb_pages else 32))

        self.fonts[fontkey] = {
            &#34;i&#34;: len(self.fonts) + 1,
            &#34;type&#34;: font_dict[&#34;type&#34;],
            &#34;name&#34;: font_dict[&#34;name&#34;],
            &#34;desc&#34;: font_dict[&#34;desc&#34;],
            &#34;up&#34;: font_dict[&#34;up&#34;],
            &#34;ut&#34;: font_dict[&#34;ut&#34;],
            &#34;cw&#34;: font_dict[&#34;cw&#34;],
            &#34;ttffile&#34;: font_dict[&#34;ttffile&#34;],
            &#34;fontkey&#34;: fontkey,
            &#34;subset&#34;: sbarr,
            &#34;unifilename&#34;: unifilename,
        }
        self.font_files[fontkey] = {
            &#34;length1&#34;: font_dict[&#34;originalsize&#34;],
            &#34;type&#34;: &#34;TTF&#34;,
            &#34;ttffile&#34;: ttffilename,
        }
        self.font_files[fname] = {&#34;type&#34;: &#34;TTF&#34;}
    else:
        font_dict = pickle.loads(fname.read_bytes())
        self.fonts[fontkey] = {&#34;i&#34;: len(self.fonts) + 1}
        self.fonts[fontkey].update(font_dict)
        diff = font_dict.get(&#34;diff&#34;)
        if diff:
            # Search existing encodings
            nb = len(self.diffs)
            for i in range(1, nb + 1):
                if self.diffs[i] == diff:
                    d = i
                    break
            else:
                d = nb + 1
                self.diffs[d] = diff
            self.fonts[fontkey][&#34;diff&#34;] = d
        filename = font_dict.get(&#34;filename&#34;)
        if filename:
            if font_dict[&#34;type&#34;] == &#34;TrueType&#34;:
                originalsize = font_dict[&#34;originalsize&#34;]
                self.font_files[filename] = {&#34;length1&#34;: originalsize}
            else:
                self.font_files[filename] = {
                    &#34;length1&#34;: font_dict[&#34;size1&#34;],
                    &#34;length2&#34;: font_dict[&#34;size2&#34;],
                }</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.add_link"><code class="name flex">
<span>def <span class="ident">add_link</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new internal link</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_link(self):
    &#34;&#34;&#34;Create a new internal link&#34;&#34;&#34;
    n = len(self.links) + 1
    self.links[n] = (0, 0)
    return n</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.add_page"><code class="name flex">
<span>def <span class="ident">add_page</span></span>(<span>self, orientation='', format='', same=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Start a new page, if same page format will be same as previous</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_page(self, orientation=&#34;&#34;, format=&#34;&#34;, same=False):
    &#34;&#34;&#34;Start a new page, if same page format will be same as previous&#34;&#34;&#34;
    if self.state == DocumentState.CLOSED:
        raise FPDFException(
            &#34;A page cannot be added on a closed document, after calling output()&#34;
        )
    if self.state == DocumentState.UNINITIALIZED:
        self.open()
    family = self.font_family
    style = f&#34;{self.font_style}U&#34; if self.underline else self.font_style
    size = self.font_size_pt
    lw = self.line_width
    dc = self.draw_color
    fc = self.fill_color
    tc = self.text_color
    stretching = self.font_stretching
    if self.page &gt; 0:
        # Page footer
        self.in_footer = 1
        self.footer()
        self.in_footer = 0
        # close page
        self._endpage()

    # Start new page
    self._beginpage(orientation, format, same)
    self._out(&#34;2 J&#34;)  # Set line cap style to square
    self.line_width = lw  # Set line width
    self._out(f&#34;{lw * self.k:.2f} w&#34;)

    # Set font
    if family:
        self.set_font(family, style, size)

    # Set colors
    self.draw_color = dc
    if dc != &#34;0 G&#34;:
        self._out(dc)
    self.fill_color = fc
    if fc != &#34;0 g&#34;:
        self._out(fc)
    self.text_color = tc

    # BEGIN Page header
    self.header()

    if self.line_width != lw:  # Restore line width
        self.line_width = lw
        self._out(f&#34;{lw * self.k:.2f} w&#34;)

    if family:
        self.set_font(family, style, size)  # Restore font

    if self.draw_color != dc:  # Restore colors
        self.draw_color = dc
        self._out(dc)
    if self.fill_color != fc:
        self.fill_color = fc
        self._out(fc)
    self.text_color = tc

    if stretching != 100:  # Restore stretching
        self.set_stretching(stretching)
    # END Page header</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.alias_nb_pages"><code class="name flex">
<span>def <span class="ident">alias_nb_pages</span></span>(<span>self, alias)</span>
</code></dt>
<dd>
<div class="desc"><p>Define an alias for total number of pages</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def alias_nb_pages(self, alias):
    &#34;&#34;&#34;Define an alias for total number of pages&#34;&#34;&#34;
    self.str_alias_nb_pages = alias</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.cell"><code class="name flex">
<span>def <span class="ident">cell</span></span>(<span>self, w, h=0, txt='', border=0, ln=0, align='', fill=False, link='')</span>
</code></dt>
<dd>
<div class="desc"><p>Output a cell, cf. <a href="https://pyfpdf.github.io/fpdf2/reference/cell.html">https://pyfpdf.github.io/fpdf2/reference/cell.html</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>w</code></strong> :&ensp;<code>int</code></dt>
<dd>Cell width. If 0, the cell extends up to the right margin.</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>int</code></dt>
<dd>Cell height. Default value: 0.</dd>
<dt><strong><code>txt</code></strong> :&ensp;<code>str</code></dt>
<dd>String to print. Default value: empty string.</dd>
<dt><strong><code>border</code></strong></dt>
<dd>Indicates if borders must be drawn around the cell.
The value can be either a number (<code>0</code>: no border ; <code>1</code>: frame)
or a string containing some or all of the following characters
(in any order):
<code>L</code>: left ; <code>T</code>: top ; <code>R</code>: right ; <code>B</code>: bottom. Default value: 0.</dd>
<dt><strong><code>ln</code></strong> :&ensp;<code>int</code></dt>
<dd>Indicates where the current position should go after the call.
Possible values are: <code>0</code>: to the right ; <code>1</code>: to the beginning of the
next line ; <code>2</code>: below. Putting 1 is equivalent to putting 0 and calling
<code>ln</code> just after. Default value: 0.</dd>
<dt><strong><code>align</code></strong> :&ensp;<code>str</code></dt>
<dd>Allows to center or align the text. Possible values are:
<code>L</code> or empty string: left align (default value) ; <code>C</code>: center ;
<code>R</code>: right align</dd>
<dt><strong><code>fill</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates if the cell background must be painted (<code>True</code>)
or transparent (<code>False</code>). Default value: False.</dd>
<dt><strong><code>link</code></strong> :&ensp;<code>str</code></dt>
<dd>optional link to add</dd>
</dl>
<p>Returns: a boolean indicating if page break was triggered</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def cell(self, w, h=0, txt=&#34;&#34;, border=0, ln=0, align=&#34;&#34;, fill=False, link=&#34;&#34;):
    &#34;&#34;&#34;
    Output a cell, cf. https://pyfpdf.github.io/fpdf2/reference/cell.html

    Args:
        w (int): Cell width. If 0, the cell extends up to the right margin.
        h (int): Cell height. Default value: 0.
        txt (str): String to print. Default value: empty string.
        border: Indicates if borders must be drawn around the cell.
            The value can be either a number (`0`: no border ; `1`: frame)
            or a string containing some or all of the following characters
            (in any order):
            `L`: left ; `T`: top ; `R`: right ; `B`: bottom. Default value: 0.
        ln (int): Indicates where the current position should go after the call.
            Possible values are: `0`: to the right ; `1`: to the beginning of the
            next line ; `2`: below. Putting 1 is equivalent to putting 0 and calling
            `ln` just after. Default value: 0.
        align (str): Allows to center or align the text. Possible values are:
            `L` or empty string: left align (default value) ; `C`: center ;
            `R`: right align
        fill (bool): Indicates if the cell background must be painted (`True`)
            or transparent (`False`). Default value: False.
        link (str): optional link to add

    Returns: a boolean indicating if page break was triggered
    &#34;&#34;&#34;
    if not self.font_family:
        raise FPDFException(&#34;No font set, you need to call set_font() beforehand&#34;)
    if isinstance(border, int) and border not in (0, 1):
        warnings.warn(
            &#39;Integer values for &#34;border&#34; parameter other than 1 are currently &#39;
            &#34;ignored&#34;
        )
        border = 1
    page_break_triggered = self.perform_page_break_if_need_be(h)
    if w == 0:
        w = self.w - self.r_margin - self.x
    s = &#34;&#34;

    k = self.k
    if fill:
        op = &#34;B&#34; if border == 1 else &#34;f&#34;
        s = (
            f&#34;{self.x * k:.2f} {(self.h - self.y) * k:.2f} &#34;
            f&#34;{w * k:.2f} {-h * k:.2f} re {op} &#34;
        )
    elif border == 1:
        s = (
            f&#34;{self.x * k:.2f} {(self.h - self.y) * k:.2f} &#34;
            f&#34;{w * k:.2f} {-h * k:.2f} re S &#34;
        )

    if isinstance(border, str):
        x = self.x
        y = self.y
        if &#34;L&#34; in border:
            s += (
                f&#34;{x * k:.2f} {(self.h - y) * k:.2f} m &#34;
                f&#34;{x * k:.2f} {(self.h - (y + h)) * k:.2f} l S &#34;
            )
        if &#34;T&#34; in border:
            s += (
                f&#34;{x * k:.2f} {(self.h - y) * k:.2f} m &#34;
                f&#34;{(x + w) * k:.2f} {(self.h - y) * k:.2f} l S &#34;
            )
        if &#34;R&#34; in border:
            s += (
                f&#34;{(x + w) * k:.2f} {(self.h - y) * k:.2f} m &#34;
                f&#34;{(x + w) * k:.2f} {(self.h - (y + h)) * k:.2f} l S &#34;
            )
        if &#34;B&#34; in border:
            s += (
                f&#34;{x * k:.2f} {(self.h - (y + h)) * k:.2f} m &#34;
                f&#34;{(x + w) * k:.2f} {(self.h - (y + h)) * k:.2f} l S &#34;
            )

    txt = self.normalize_text(txt)
    if txt != &#34;&#34;:
        if align == &#34;R&#34;:
            dx = w - self.c_margin - self.get_string_width(txt, True)
        elif align == &#34;C&#34;:
            dx = (w - self.get_string_width(txt, True)) / 2
        else:
            dx = self.c_margin
        if self.fill_color != self.text_color:
            s += f&#34;q {self.text_color} &#34;

        # If multibyte, Tw has no effect - do word spacing using an
        # adjustment before each space
        if self.ws and self.unifontsubset:
            for char in txt:
                self.current_font[&#34;subset&#34;].append(ord(char))
            space = escape_parens(&#34; &#34;.encode(&#34;UTF-16BE&#34;).decode(&#34;latin-1&#34;))

            s += (
                f&#34;BT 0 Tw {(self.x + dx) * k:.2F} &#34;
                f&#34;{(self.h - self.y - 0.5 * h - 0.3 * self.font_size) * k:.2F} &#34;
                f&#34;Td [&#34;
            )

            t = txt.split(&#34; &#34;)
            numt = len(t)
            for i in range(numt):
                tx = t[i]
                tx = enclose_in_parens(
                    escape_parens(tx.encode(&#34;UTF-16BE&#34;).decode(&#34;latin-1&#34;))
                )
                s += f&#34;{tx} &#34;
                if (i + 1) &lt; numt:
                    adj = -(self.ws * self.k) * 1000 / self.font_size_pt
                    s += f&#34;{adj}({space}) &#34;
            s += &#34;] TJ&#34;
            s += &#34; ET&#34;
        else:
            if self.unifontsubset:
                txt2 = escape_parens(txt.encode(&#34;UTF-16BE&#34;).decode(&#34;latin-1&#34;))
                for char in txt:
                    self.current_font[&#34;subset&#34;].append(ord(char))
            else:
                txt2 = escape_parens(txt)

            s += (
                f&#34;BT {(self.x + dx) * k:.2f} &#34;
                f&#34;{(self.h - self.y - 0.5 * h - 0.3 * self.font_size) * k:.2f} &#34;
                f&#34;Td ({txt2}) Tj ET&#34;
            )

        if self.underline:
            s += &#34; &#34; + self._dounderline(
                self.x + dx, self.y + (0.5 * h) + (0.3 * self.font_size), txt
            )
        if self.fill_color != self.text_color:
            s += &#34; Q&#34;
        if link:
            self.link(
                self.x + dx,
                self.y + (0.5 * h) - (0.5 * self.font_size),
                self.get_string_width(txt, True),
                self.font_size,
                link,
            )
    if s:
        self._out(s)
    self.lasth = h

    if ln &gt; 0:
        self.y += h  # Go to next line
        if ln == 1:
            self.x = self.l_margin
    else:
        self.x += w

    return page_break_triggered</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Terminate document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    &#34;&#34;&#34;Terminate document&#34;&#34;&#34;
    if self.state == DocumentState.CLOSED:
        return
    if self.page == 0:
        self.add_page()

    # Page footer
    self.in_footer = 1
    self.footer()
    self.in_footer = 0

    self._endpage()  # close page
    self._enddoc()  # close document</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.code39"><code class="name flex">
<span>def <span class="ident">code39</span></span>(<span>self, txt, x, y, w=1.5, h=5)</span>
</code></dt>
<dd>
<div class="desc"><p>Barcode 3of9</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def code39(self, txt, x, y, w=1.5, h=5):
    &#34;&#34;&#34;Barcode 3of9&#34;&#34;&#34;
    dim = {&#34;w&#34;: w, &#34;n&#34;: w / 3}
    chars = {
        &#34;0&#34;: &#34;nnnwwnwnn&#34;,
        &#34;1&#34;: &#34;wnnwnnnnw&#34;,
        &#34;2&#34;: &#34;nnwwnnnnw&#34;,
        &#34;3&#34;: &#34;wnwwnnnnn&#34;,
        &#34;4&#34;: &#34;nnnwwnnnw&#34;,
        &#34;5&#34;: &#34;wnnwwnnnn&#34;,
        &#34;6&#34;: &#34;nnwwwnnnn&#34;,
        &#34;7&#34;: &#34;nnnwnnwnw&#34;,
        &#34;8&#34;: &#34;wnnwnnwnn&#34;,
        &#34;9&#34;: &#34;nnwwnnwnn&#34;,
        &#34;A&#34;: &#34;wnnnnwnnw&#34;,
        &#34;B&#34;: &#34;nnwnnwnnw&#34;,
        &#34;C&#34;: &#34;wnwnnwnnn&#34;,
        &#34;D&#34;: &#34;nnnnwwnnw&#34;,
        &#34;E&#34;: &#34;wnnnwwnnn&#34;,
        &#34;F&#34;: &#34;nnwnwwnnn&#34;,
        &#34;G&#34;: &#34;nnnnnwwnw&#34;,
        &#34;H&#34;: &#34;wnnnnwwnn&#34;,
        &#34;I&#34;: &#34;nnwnnwwnn&#34;,
        &#34;J&#34;: &#34;nnnnwwwnn&#34;,
        &#34;K&#34;: &#34;wnnnnnnww&#34;,
        &#34;L&#34;: &#34;nnwnnnnww&#34;,
        &#34;M&#34;: &#34;wnwnnnnwn&#34;,
        &#34;N&#34;: &#34;nnnnwnnww&#34;,
        &#34;O&#34;: &#34;wnnnwnnwn&#34;,
        &#34;P&#34;: &#34;nnwnwnnwn&#34;,
        &#34;Q&#34;: &#34;nnnnnnwww&#34;,
        &#34;R&#34;: &#34;wnnnnnwwn&#34;,
        &#34;S&#34;: &#34;nnwnnnwwn&#34;,
        &#34;T&#34;: &#34;nnnnwnwwn&#34;,
        &#34;U&#34;: &#34;wwnnnnnnw&#34;,
        &#34;V&#34;: &#34;nwwnnnnnw&#34;,
        &#34;W&#34;: &#34;wwwnnnnnn&#34;,
        &#34;X&#34;: &#34;nwnnwnnnw&#34;,
        &#34;Y&#34;: &#34;wwnnwnnnn&#34;,
        &#34;Z&#34;: &#34;nwwnwnnnn&#34;,
        &#34;-&#34;: &#34;nwnnnnwnw&#34;,
        &#34;.&#34;: &#34;wwnnnnwnn&#34;,
        &#34; &#34;: &#34;nwwnnnwnn&#34;,
        &#34;*&#34;: &#34;nwnnwnwnn&#34;,
        &#34;$&#34;: &#34;nwnwnwnnn&#34;,
        &#34;/&#34;: &#34;nwnwnnnwn&#34;,
        &#34;+&#34;: &#34;nwnnnwnwn&#34;,
        &#34;%&#34;: &#34;nnnwnwnwn&#34;,
    }
    self.set_fill_color(0)
    for c in txt.upper():
        if c not in chars:
            raise RuntimeError(f&#39;Invalid char &#34;{c}&#34; for Code39&#39;)
        for i, d in enumerate(chars[c]):
            if i % 2 == 0:
                self.rect(x, y, dim[d], h, &#34;F&#34;)
            x += dim[d]
        x += dim[&#34;n&#34;]</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.dashed_line"><code class="name flex">
<span>def <span class="ident">dashed_line</span></span>(<span>self, x1, y1, x2, y2, dash_length=1, space_length=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw a dashed line. Same interface as line() except:
- dash_length: Length of the dash
- space_length: Length of the space between dashes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def dashed_line(self, x1, y1, x2, y2, dash_length=1, space_length=1):
    &#34;&#34;&#34;Draw a dashed line. Same interface as line() except:
    - dash_length: Length of the dash
    - space_length: Length of the space between dashes&#34;&#34;&#34;
    self._set_dash(dash_length, space_length)
    self.line(x1, y1, x2, y2)
    self._set_dash()</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.ellipse"><code class="name flex">
<span>def <span class="ident">ellipse</span></span>(<span>self, x, y, w, h, style=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw a ellipse</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def ellipse(self, x, y, w, h, style=None):
    &#34;&#34;&#34;Draw a ellipse&#34;&#34;&#34;
    style_to_operators = {&#34;F&#34;: &#34;f&#34;, &#34;FD&#34;: &#34;B&#34;, &#34;DF&#34;: &#34;B&#34;}
    op = style_to_operators.get(style, &#34;S&#34;)

    cx = x + w / 2
    cy = y + h / 2
    rx = w / 2
    ry = h / 2

    lx = 4 / 3 * (math.sqrt(2) - 1) * rx
    ly = 4 / 3 * (math.sqrt(2) - 1) * ry

    self._out(
        (
            f&#34;{(cx + rx) * self.k:.2f} {(self.h - cy) * self.k:.2f} m &#34;
            f&#34;{(cx + rx) * self.k:.2f} {(self.h - cy + ly) * self.k:.2f} &#34;
            f&#34;{(cx + lx) * self.k:.2f} {(self.h - cy + ry) * self.k:.2f} &#34;
            f&#34;{cx * self.k:.2f} {(self.h - cy + ry) * self.k:.2f} c&#34;
        )
    )
    self._out(
        (
            f&#34;{(cx - lx) * self.k:.2f} {(self.h - cy + ry) * self.k:.2f} &#34;
            f&#34;{(cx - rx) * self.k:.2f} {(self.h - cy + ly) * self.k:.2f} &#34;
            f&#34;{(cx - rx) * self.k:.2f} {(self.h - cy) * self.k:.2f} c&#34;
        )
    )
    self._out(
        (
            f&#34;{(cx - rx) * self.k:.2f} {(self.h - cy - ly) * self.k:.2f} &#34;
            f&#34;{(cx - lx) * self.k:.2f} {(self.h - cy - ry) * self.k:.2f} &#34;
            f&#34;{cx * self.k:.2f} {(self.h - cy - ry) * self.k:.2f} c&#34;
        )
    )
    self._out(
        (
            f&#34;{(cx + lx) * self.k:.2f} {(self.h - cy - ry) * self.k:.2f} &#34;
            f&#34;{(cx + rx) * self.k:.2f} {(self.h - cy - ly) * self.k:.2f} &#34;
            f&#34;{(cx + rx) * self.k:.2f} {(self.h - cy) * self.k:.2f} c {op}&#34;
        )
    )</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.footer"><code class="name flex">
<span>def <span class="ident">footer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Footer to be implemented in your own inherited class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def footer(self):
    &#34;&#34;&#34;Footer to be implemented in your own inherited class&#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.get_string_width"><code class="name flex">
<span>def <span class="ident">get_string_width</span></span>(<span>self, s, normalized=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Get width of a string in the current font</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_string_width(self, s, normalized=False):
    &#34;&#34;&#34;Get width of a string in the current font&#34;&#34;&#34;
    # normalized is parameter for internal use
    s = s if normalized else self.normalize_text(s)
    cw = self.current_font[&#34;cw&#34;]
    w = 0
    if self.unifontsubset:
        for char in s:
            char = ord(char)
            if len(cw) &gt; char:
                w += cw[char]
            elif self.current_font[&#34;desc&#34;][&#34;MissingWidth&#34;]:
                w += self.current_font[&#34;desc&#34;][&#34;MissingWidth&#34;]
            else:
                w += 500
    else:
        w += sum(cw.get(char, 0) for char in s)
    if self.font_stretching != 100:
        w = w * self.font_stretching / 100
    return w * self.font_size / 1000</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.get_x"><code class="name flex">
<span>def <span class="ident">get_x</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get x position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_x(self):
    &#34;&#34;&#34;Get x position&#34;&#34;&#34;
    return self.x</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.get_y"><code class="name flex">
<span>def <span class="ident">get_y</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get y position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_y(self):
    &#34;&#34;&#34;Get y position&#34;&#34;&#34;
    return self.y</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.header"><code class="name flex">
<span>def <span class="ident">header</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Header to be implemented in your own inherited class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def header(self):
    &#34;&#34;&#34;Header to be implemented in your own inherited class&#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.image"><code class="name flex">
<span>def <span class="ident">image</span></span>(<span>self, name, x=None, y=None, w=0, h=0, type='', link='')</span>
</code></dt>
<dd>
<div class="desc"><p>Put an image on the page</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>either a string representing a file path to an image, or a instance of</dd>
<dt><code>PIL.Image.Image</code></dt>
<dt><strong><code>x</code></strong> :&ensp;<code>int</code></dt>
<dd>optional horizontal position where to put the image on the page</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>int</code></dt>
<dd>optional vertical position where to put the image on the page</dd>
<dt><strong><code>w</code></strong> :&ensp;<code>int</code></dt>
<dd>optional width of the image</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>int</code></dt>
<dd>optional height of the image</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>str</code></dt>
<dd>[<strong>DEPRECATED</strong>] unused, will be removed in a later version</dd>
<dt><strong><code>link</code></strong> :&ensp;<code>str</code></dt>
<dd>optional link, internal or external, to add on the image</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def image(
    self,
    name,
    x=None,
    y=None,
    w=0,
    h=0,
    type=&#34;&#34;,
    link=&#34;&#34;,
):
    &#34;&#34;&#34;
    Put an image on the page

    Args:
        name: either a string representing a file path to an image, or a instance of
        `PIL.Image.Image`
        x (int): optional horizontal position where to put the image on the page
        y (int): optional vertical position where to put the image on the page
        w (int): optional width of the image
        h (int): optional height of the image
        type (str): [**DEPRECATED**] unused, will be removed in a later version
        link (str): optional link, internal or external, to add on the image
    &#34;&#34;&#34;
    if type:
        warnings.warn(
            &#39;&#34;type&#34; is unused and will soon be deprecated&#39;,
            PendingDeprecationWarning,
        )
    if isinstance(name, str):
        img = load_resource(name)
    else:
        name, img = uuid4(), name
    if name not in self.images:
        info = get_img_info(img)
        info[&#34;i&#34;] = len(self.images) + 1
        self.images[name] = info
    else:
        info = self.images[name]

    # Automatic width and height calculation if needed
    if w == 0 and h == 0:
        # Put image at 72 dpi
        w = info[&#34;w&#34;] / self.k
        h = info[&#34;h&#34;] / self.k
    elif w == 0:
        w = h * info[&#34;w&#34;] / info[&#34;h&#34;]
    elif h == 0:
        h = w * info[&#34;h&#34;] / info[&#34;w&#34;]

    # Flowing mode
    if y is None:
        self.perform_page_break_if_need_be(h)
        y = self.y
        self.y += h

    if x is None:
        x = self.x
    self._out(
        (
            f&#34;q {w * self.k:.2f} 0 0 {h * self.k:.2f} {x * self.k:.2f} &#34;
            f&#34;{(self.h - y - h) * self.k:.2f} cm /I{info[&#39;i&#39;]} Do Q&#34;
        )
    )
    if link:
        self.link(x, y, w, h, link)

    return info</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.interleaved2of5"><code class="name flex">
<span>def <span class="ident">interleaved2of5</span></span>(<span>self, txt, x, y, w=1, h=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Barcode I2of5 (numeric), adds a 0 if odd length</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def interleaved2of5(self, txt, x, y, w=1, h=10):
    &#34;&#34;&#34;Barcode I2of5 (numeric), adds a 0 if odd length&#34;&#34;&#34;
    narrow = w / 3
    wide = w

    # wide/narrow codes for the digits
    bar_char = {
        &#34;0&#34;: &#34;nnwwn&#34;,
        &#34;1&#34;: &#34;wnnnw&#34;,
        &#34;2&#34;: &#34;nwnnw&#34;,
        &#34;3&#34;: &#34;wwnnn&#34;,
        &#34;4&#34;: &#34;nnwnw&#34;,
        &#34;5&#34;: &#34;wnwnn&#34;,
        &#34;6&#34;: &#34;nwwnn&#34;,
        &#34;7&#34;: &#34;nnnww&#34;,
        &#34;8&#34;: &#34;wnnwn&#34;,
        &#34;9&#34;: &#34;nwnwn&#34;,
        &#34;A&#34;: &#34;nn&#34;,
        &#34;Z&#34;: &#34;wn&#34;,
    }

    self.set_fill_color(0)
    code = txt
    # add leading zero if code-length is odd
    if len(code) % 2 != 0:
        code = f&#34;0{code}&#34;

    # add start and stop codes
    code = f&#34;AA{code.lower()}ZA&#34;

    for i in range(0, len(code), 2):
        # choose next pair of digits
        char_bar = code[i]
        char_space = code[i + 1]
        # check whether it is a valid digit
        if char_bar not in bar_char:
            raise RuntimeError(f&#39;Char &#34;{char_bar}&#34; invalid for I25:&#39;)
        if char_space not in bar_char:
            raise RuntimeError(f&#39;Char &#34;{char_space}&#34; invalid for I25: &#39;)

        # create a wide/narrow-seq (first digit=bars, second digit=spaces)
        seq = &#34;&#34;.join(
            f&#34;{cb}{cs}&#34; for cb, cs in zip(bar_char[char_bar], bar_char[char_space])
        )

        for bar, char in enumerate(seq):
            # set line_width depending on value
            line_width = narrow if char == &#34;n&#34; else wide

            # draw every second value, the other is represented by space
            if bar % 2 == 0:
                self.rect(x, y, line_width, h, &#34;F&#34;)

            x += line_width</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.line"><code class="name flex">
<span>def <span class="ident">line</span></span>(<span>self, x1, y1, x2, y2)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw a line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def line(self, x1, y1, x2, y2):
    &#34;&#34;&#34;Draw a line&#34;&#34;&#34;
    self._out(
        f&#34;{x1 * self.k:.2f} {(self.h - y1) * self.k:.2f} m {x2 * self.k:.2f} &#34;
        f&#34;{(self.h - y2) * self.k:.2f} l S&#34;
    )</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.link"><code class="name flex">
<span>def <span class="ident">link</span></span>(<span>self, x, y, w, h, link, alt_text='')</span>
</code></dt>
<dd>
<div class="desc"><p>Put a link on the page</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def link(self, x, y, w, h, link, alt_text=&#34;&#34;):
    &#34;&#34;&#34;Put a link on the page&#34;&#34;&#34;
    if self.page not in self.page_links:
        self.page_links[self.page] = []
    self.page_links[self.page] += [
        (x * self.k, self.h_pt - y * self.k, w * self.k, h * self.k, link, alt_text)
    ]</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.ln"><code class="name flex">
<span>def <span class="ident">ln</span></span>(<span>self, h=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Line Feed.
The current abscissa goes back to the left margin and the ordinate increases by
the amount passed as parameter.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>h</code></strong> :&ensp;<code>int</code></dt>
<dd>The height of the break.
By default, the value equals the height of the last printed cell.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def ln(self, h=None):
    &#34;&#34;&#34;
    Line Feed.
    The current abscissa goes back to the left margin and the ordinate increases by
    the amount passed as parameter.

    Args:
        h (int): The height of the break.
            By default, the value equals the height of the last printed cell.
    &#34;&#34;&#34;
    self.x = self.l_margin
    self.y += self.lasth if h is None else h</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.multi_cell"><code class="name flex">
<span>def <span class="ident">multi_cell</span></span>(<span>self, w, h, txt='', border=0, align='J', fill=False, split_only=False, link='', ln=0, max_line_height=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Output text with line breaks, cf.
<a href="https://pyfpdf.github.io/fpdf2/reference/multi_cell.html">https://pyfpdf.github.io/fpdf2/reference/multi_cell.html</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>w</code></strong> :&ensp;<code>int</code></dt>
<dd>cells width. If 0, they extend up to the right margin of the page.</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>int</code></dt>
<dd>cells height.</dd>
<dt><strong><code>txt</code></strong> :&ensp;<code>str</code></dt>
<dd>strign to print.</dd>
<dt><strong><code>border</code></strong></dt>
<dd>Indicates if borders must be drawn around the cell.
The value can be either a number (<code>0</code>: no border ; <code>1</code>: frame)
or a string containing some or all of the following characters
(in any order):
<code>L</code>: left ; <code>T</code>: top ; <code>R</code>: right ; <code>B</code>: bottom. Default value: 0.</dd>
<dt><strong><code>align</code></strong> :&ensp;<code>str</code></dt>
<dd>Allows to center or align the text. Possible values are:
<code>L</code> or empty string: left align (default value) ; <code>C</code>: center ;
<code>R</code>: right align</dd>
<dt><strong><code>fill</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates if the cell background must be painted (<code>True</code>)
or transparent (<code>False</code>). Default value: False.</dd>
<dt><strong><code>split_only</code></strong> :&ensp;<code>bool</code></dt>
<dd>if <code>True</code>, does not output anything, only perform
word-wrapping and return the resulting multi-lines array of strings.</dd>
<dt><strong><code>link</code></strong> :&ensp;<code>str</code></dt>
<dd>optional link to add</dd>
<dt><strong><code>ln</code></strong> :&ensp;<code>int</code></dt>
<dd>Indicates where the current position should go after the call.
Possible values are: <code>0</code>: to the bottom right ; <code>1</code>: to the beginning
of the next line ; <code>2</code>: below with the same horizontal offset ;
<code>3</code>: to the right with the same vertical offset. Default value: 0.</dd>
<dt><strong><code>max_line_height</code></strong> :&ensp;<code>int</code></dt>
<dd>optional maximum height of each sub-cell generated</dd>
</dl>
<p>Using <code>ln=3</code> and <code>maximum height=pdf.font_size</code> is useful to build tables
with multiline text in cells.</p>
<p>Returns: a boolean indicating if page break was triggered.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def multi_cell(
    self,
    w,
    h,
    txt=&#34;&#34;,
    border=0,
    align=&#34;J&#34;,
    fill=False,
    split_only=False,
    link=&#34;&#34;,
    ln=0,
    max_line_height=None,
):
    &#34;&#34;&#34;
    Output text with line breaks, cf.
    https://pyfpdf.github.io/fpdf2/reference/multi_cell.html

    Args:
        w (int): cells width. If 0, they extend up to the right margin of the page.
        h (int): cells height.
        txt (str): strign to print.
        border: Indicates if borders must be drawn around the cell.
            The value can be either a number (`0`: no border ; `1`: frame)
            or a string containing some or all of the following characters
            (in any order):
            `L`: left ; `T`: top ; `R`: right ; `B`: bottom. Default value: 0.
        align (str): Allows to center or align the text. Possible values are:
            `L` or empty string: left align (default value) ; `C`: center ;
            `R`: right align
        fill (bool): Indicates if the cell background must be painted (`True`)
            or transparent (`False`). Default value: False.
        split_only (bool): if `True`, does not output anything, only perform
            word-wrapping and return the resulting multi-lines array of strings.
        link (str): optional link to add
        ln (int): Indicates where the current position should go after the call.
            Possible values are: `0`: to the bottom right ; `1`: to the beginning
            of the next line ; `2`: below with the same horizontal offset ;
            `3`: to the right with the same vertical offset. Default value: 0.
        max_line_height (int): optional maximum height of each sub-cell generated

    Using `ln=3` and `maximum height=pdf.font_size` is useful to build tables
    with multiline text in cells.

    Returns: a boolean indicating if page break was triggered.
    &#34;&#34;&#34;
    page_break_triggered = False
    if split_only:
        _out, _add_page = self._out, self.add_page
        self._out = lambda *args, **kwargs: None
        self.add_page = lambda *args, **kwargs: None

    # Store this information for manipulating position.
    location = (self.get_x(), self.get_y())

    # If width is 0, set width to available width between margins
    if w == 0:
        w = self.w - self.r_margin - self.x
    wmax = (w - 2 * self.c_margin) * 1000 / self.font_size

    # Calculate text length
    txt = self.normalize_text(txt)
    s = txt.replace(&#34;\r&#34;, &#34;&#34;)
    normalized_string_length = len(s)
    if normalized_string_length &gt; 0 and s[-1] == &#34;\n&#34;:
        normalized_string_length -= 1

    b = 0
    if border:
        if border == 1:
            border = &#34;LTRB&#34;
            b = &#34;LRT&#34;
            b2 = &#34;LR&#34;
        else:
            b2 = &#34;&#34;
            if &#34;L&#34; in border:
                b2 += &#34;L&#34;
            if &#34;R&#34; in border:
                b2 += &#34;R&#34;
            b = b2 + &#34;T&#34; if &#34;T&#34; in border else b2
    character_widths = self.current_font[&#34;cw&#34;]
    text_cells = []
    sep = -1
    i = 0
    j = 0
    l = 0
    ns = 0
    nl = 1
    prev_x, prev_y = self.x, self.y
    while i &lt; normalized_string_length:
        # Get next character
        c = s[i]

        # Explicit line break
        if c == &#34;\n&#34;:
            if self.ws &gt; 0:
                self.ws = 0
                self._out(&#34;0 Tw&#34;)

            if max_line_height and h &gt; max_line_height:
                height = max_line_height
                h -= height
            else:
                height = h
            new_page = self.cell(
                w,
                h=height,
                txt=substr(s, j, i - j),
                border=b,
                ln=2,
                align=align,
                fill=fill,
                link=link,
            )
            page_break_triggered = page_break_triggered or new_page
            text_cells.append(substr(s, j, i - j))

            i += 1
            sep = -1
            j = i
            l = 0
            ns = 0
            nl += 1
            if border and nl == 2:
                b = b2
            continue

        if c == &#34; &#34;:
            sep = i
            ls = l
            ns += 1
        if self.unifontsubset:
            l += self.get_string_width(c, True) / self.font_size * 1000
        else:
            l += character_widths.get(c, 0)

        # Automatic line break
        if l &gt; wmax:
            if sep == -1:
                if i == j:
                    i += 1
                if self.ws &gt; 0:
                    self.ws = 0
                    self._out(&#34;0 Tw&#34;)

                if max_line_height and h &gt; max_line_height:
                    height = max_line_height
                    h -= height
                else:
                    height = h
                new_page = self.cell(
                    w,
                    h=height,
                    txt=substr(s, j, i - j),
                    border=b,
                    ln=2,
                    align=align,
                    fill=fill,
                    link=link,
                )
                page_break_triggered = page_break_triggered or new_page
                text_cells.append(substr(s, j, i - j))

            else:
                if align == &#34;J&#34;:
                    self.ws = (
                        (wmax - ls) / 1000 * self.font_size / (ns - 1)
                        if ns &gt; 1
                        else 0
                    )
                    self._out(f&#34;{self.ws * self.k:.3f} Tw&#34;)

                if max_line_height and h &gt; max_line_height:
                    height = max_line_height
                    h -= height
                else:
                    height = h
                new_page = self.cell(
                    w,
                    h=height,
                    txt=substr(s, j, sep - j),
                    border=b,
                    ln=2,
                    align=align,
                    fill=fill,
                    link=link,
                )
                page_break_triggered = page_break_triggered or new_page
                text_cells.append(substr(s, j, sep - j))

                i = sep + 1
            sep = -1
            j = i
            l = 0
            ns = 0
            nl += 1
            if border and nl == 2:
                b = b2
        else:
            i += 1

    # Last chunk
    if self.ws &gt; 0:
        self.ws = 0
        self._out(&#34;0 Tw&#34;)
    if border and &#34;B&#34; in border:
        b += &#34;B&#34;

    new_page = self.cell(
        w,
        h=h,
        txt=substr(s, j, i - j),
        border=b,
        ln=0 if ln == 3 else ln,
        align=align,
        fill=fill,
        link=link,
    )
    page_break_triggered = page_break_triggered or new_page
    text_cells.append(substr(s, j, i - j))

    new_x, new_y = {
        0: (self.x, self.y + h),
        1: (self.l_margin, self.y),
        2: (prev_x, self.y),
        3: (self.x, prev_y),
    }[ln]
    self.set_xy(new_x, new_y)

    if split_only:
        # restore writing functions
        self._out, self.add_page = _out, _add_page
        self.set_xy(*location)  # restore location
        return text_cells

    return page_break_triggered</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.normalize_text"><code class="name flex">
<span>def <span class="ident">normalize_text</span></span>(<span>self, txt)</span>
</code></dt>
<dd>
<div class="desc"><p>Check that text input is in the correct format/encoding</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize_text(self, txt):
    &#34;&#34;&#34;Check that text input is in the correct format/encoding&#34;&#34;&#34;
    # - for TTF unicode fonts: unicode object (utf8 encoding)
    # - for built-in fonts: string instances (encoding: latin-1, cp1252)
    if not self.unifontsubset and self.core_fonts_encoding:
        return txt.encode(self.core_fonts_encoding).decode(&#34;latin-1&#34;)
    return txt</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Begin document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(self):
    &#34;&#34;&#34;Begin document&#34;&#34;&#34;
    self.state = DocumentState.READY</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.output"><code class="name flex">
<span>def <span class="ident">output</span></span>(<span>self, name='', dest='')</span>
</code></dt>
<dd>
<div class="desc"><p>Output PDF to some destination.</p>
<p>By default the bytearray buffer is returned.
If a <code>name</code> is given, the PDF is written to a new file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>optional File object or file path where to save the PDF under</dd>
<dt><strong><code>dest</code></strong> :&ensp;<code>str</code></dt>
<dd>[<strong>DEPRECATED</strong>] unused, will be removed in a later version</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output(self, name=&#34;&#34;, dest=&#34;&#34;):
    &#34;&#34;&#34;
    Output PDF to some destination.

    By default the bytearray buffer is returned.
    If a `name` is given, the PDF is written to a new file.

    Args:
        name (str): optional File object or file path where to save the PDF under
        dest (str): [**DEPRECATED**] unused, will be removed in a later version
    &#34;&#34;&#34;
    if dest:
        warnings.warn(
            &#39;&#34;dest&#34; is unused and will soon be deprecated&#39;,
            PendingDeprecationWarning,
        )
    # Finish document if necessary:
    if self.state &lt; DocumentState.CLOSED:
        self.close()
    if name:
        if isinstance(name, os.PathLike):
            name.write_bytes(self.buffer)
        elif isinstance(name, str):
            Path(name).write_bytes(self.buffer)
        else:
            name.write(self.buffer)
        return None
    return self.buffer</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.page_no"><code class="name flex">
<span>def <span class="ident">page_no</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get current page number</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def page_no(self):
    &#34;&#34;&#34;Get current page number&#34;&#34;&#34;
    return self.page</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.perform_page_break_if_need_be"><code class="name flex">
<span>def <span class="ident">perform_page_break_if_need_be</span></span>(<span>self, h)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def perform_page_break_if_need_be(self, h):
    if (
        self.y + h &gt; self.page_break_trigger
        and not self.in_footer
        and self.accept_page_break
    ):
        LOGGER.info(
            &#34;Page break on page %d at y=%d for element of height %d&#34;,
            self.page,
            self.y,
            h,
        )
        x, ws = self.x, self.ws
        if ws &gt; 0:
            self.ws = 0
            self._out(&#34;0 Tw&#34;)
        self.add_page(same=True)
        self.x = x  # restore x but not y after drawing header
        if ws &gt; 0:
            self.ws = ws
            self._out(f&#34;{ws * self.k:.3f} Tw&#34;)
        return True
    return False</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.rect"><code class="name flex">
<span>def <span class="ident">rect</span></span>(<span>self, x, y, w, h, style=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw a rectangle</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def rect(self, x, y, w, h, style=None):
    &#34;&#34;&#34;Draw a rectangle&#34;&#34;&#34;
    style_to_operators = {&#34;F&#34;: &#34;f&#34;, &#34;FD&#34;: &#34;B&#34;, &#34;DF&#34;: &#34;B&#34;}
    op = style_to_operators.get(style, &#34;S&#34;)
    self._out(
        f&#34;{x * self.k:.2f} {(self.h - y) * self.k:.2f} {w * self.k:.2f} &#34;
        f&#34;{-h * self.k:.2f} re {op}&#34;
    )</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.rect_clip"><code class="name flex">
<span>def <span class="ident">rect_clip</span></span>(<span>self, x, y, w, h)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
@contextmanager
def rect_clip(self, x, y, w, h):
    self._out(
        (
            f&#34;q {x * self.k:.2f} {(self.h - y - h) * self.k:.2f} {w * self.k:.2f} &#34;
            f&#34;{h * self.k:.2f} re W n\n&#34;
        )
    )
    yield
    self._out(&#34;Q\n&#34;)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.rotate"><code class="name flex">
<span>def <span class="ident">rotate</span></span>(<span>self, angle, x=None, y=None)</span>
</code></dt>
<dd>
<div class="desc"><div class="admonition deprecated">
<p class="admonition-title">Deprecated since version:&ensp;2.1.0</p>
<p>Use <code>rotation</code> instead.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def rotate(self, angle, x=None, y=None):
    &#34;&#34;&#34;
    .. deprecated:: 2.1.0
      Use `rotation` instead.
    &#34;&#34;&#34;
    warnings.warn(
        &#34;rotate() can produces malformed PDFs and is deprecated. &#34;
        &#34;Use the rotation() context manager instead.&#34;,
        PendingDeprecationWarning,
    )
    if x is None:
        x = self.x
    if y is None:
        y = self.y

    if self.angle != 0:
        self._out(&#34;Q&#34;)
    self.angle = angle
    if angle != 0:
        angle *= math.pi / 180
        c = math.cos(angle)
        s = math.sin(angle)
        cx = x * self.k
        cy = (self.h - y) * self.k
        s = (
            f&#34;q {c:.5F} {s:.5F} {-s:.5F} {c:.5F} {cx:.2F} {cy:.2F} cm &#34;
            f&#34;1 0 0 1 {-cx:.2F} {-cy:.2F} cm&#34;
        )
        self._out(s)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.rotation"><code class="name flex">
<span>def <span class="ident">rotation</span></span>(<span>self, angle, x=None, y=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This method allows to perform a rotation around a given center.</p>
<p>The rotation affects all elements which are printed inside the indented context
(with the exception of clickable areas).</p>
<h2 id="notes">Notes</h2>
<p>Only the rendering is altered. The <code>get_x()</code> and <code>get_y()</code> methods are not
affected, nor the automatic page break mechanism.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
@contextmanager
def rotation(self, angle, x=None, y=None):
    &#34;&#34;&#34;
    This method allows to perform a rotation around a given center.

    The rotation affects all elements which are printed inside the indented context
    (with the exception of clickable areas).

    Notes
    -----

    Only the rendering is altered. The `get_x()` and `get_y()` methods are not
    affected, nor the automatic page break mechanism.
    &#34;&#34;&#34;
    if x is None:
        x = self.x
    if y is None:
        y = self.y
    angle *= math.pi / 180
    c, s = math.cos(angle), math.sin(angle)
    cx, cy = x * self.k, (self.h - y) * self.k
    s = (
        f&#34;q {c:.5F} {s:.5F} {-s:.5F} {c:.5F} {cx:.2F} {cy:.2F} cm &#34;
        f&#34;1 0 0 1 {-cx:.2F} {-cy:.2F} cm\n&#34;
    )
    self._out(s)
    yield
    self._out(&#34;Q\n&#34;)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_author"><code class="name flex">
<span>def <span class="ident">set_author</span></span>(<span>self, author)</span>
</code></dt>
<dd>
<div class="desc"><p>Author of document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_author(self, author):
    &#34;&#34;&#34;Author of document&#34;&#34;&#34;
    self.author = author</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_auto_page_break"><code class="name flex">
<span>def <span class="ident">set_auto_page_break</span></span>(<span>self, auto, margin=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Set auto page break mode and triggering margin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_auto_page_break(self, auto, margin=0):
    &#34;&#34;&#34;Set auto page break mode and triggering margin&#34;&#34;&#34;
    self.auto_page_break = auto
    self.b_margin = margin
    self.page_break_trigger = self.h - margin</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_compression"><code class="name flex">
<span>def <span class="ident">set_compression</span></span>(<span>self, compress)</span>
</code></dt>
<dd>
<div class="desc"><p>Set page compression</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_compression(self, compress):
    &#34;&#34;&#34;Set page compression&#34;&#34;&#34;
    self.compress = compress</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_creation_date"><code class="name flex">
<span>def <span class="ident">set_creation_date</span></span>(<span>self, date=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets Creation of Date time, or current time if None given.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_creation_date(self, date=None):
    &#34;&#34;&#34;Sets Creation of Date time, or current time if None given.&#34;&#34;&#34;
    self.creation_date = datetime.now() if date is None else date</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_creator"><code class="name flex">
<span>def <span class="ident">set_creator</span></span>(<span>self, creator)</span>
</code></dt>
<dd>
<div class="desc"><p>Creator of document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_creator(self, creator):
    &#34;&#34;&#34;Creator of document&#34;&#34;&#34;
    self.creator = creator</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_display_mode"><code class="name flex">
<span>def <span class="ident">set_display_mode</span></span>(<span>self, zoom, layout='continuous')</span>
</code></dt>
<dd>
<div class="desc"><p>Set display mode in viewer</p>
<p>The "zoom" argument may be 'fullpage', 'fullwidth', 'real',
'default', or a number, interpreted as a percentage.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_display_mode(self, zoom, layout=&#34;continuous&#34;):
    &#34;&#34;&#34;Set display mode in viewer

    The &#34;zoom&#34; argument may be &#39;fullpage&#39;, &#39;fullwidth&#39;, &#39;real&#39;,
    &#39;default&#39;, or a number, interpreted as a percentage.
    &#34;&#34;&#34;
    if zoom in [&#34;fullpage&#34;, &#34;fullwidth&#34;, &#34;real&#34;, &#34;default&#34;] or not isinstance(
        zoom, str
    ):
        self.zoom_mode = zoom
    else:
        raise FPDFException(f&#34;Incorrect zoom display mode: {zoom}&#34;)

    if layout in [&#34;single&#34;, &#34;continuous&#34;, &#34;two&#34;, &#34;default&#34;]:
        self.layout_mode = layout
    else:
        raise FPDFException(f&#34;Incorrect layout display mode: {layout}&#34;)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_doc_option"><code class="name flex">
<span>def <span class="ident">set_doc_option</span></span>(<span>self, opt, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Set document option</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_doc_option(self, opt, value):
    &#34;&#34;&#34;Set document option&#34;&#34;&#34;
    if opt == &#34;core_fonts_encoding&#34;:
        self.core_fonts_encoding = value
    else:
        raise FPDFException(f&#39;Unknown document option &#34;{opt}&#34;&#39;)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_draw_color"><code class="name flex">
<span>def <span class="ident">set_draw_color</span></span>(<span>self, r, g=-1, b=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Set color for all stroking operations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_draw_color(self, r, g=-1, b=-1):
    &#34;&#34;&#34;Set color for all stroking operations&#34;&#34;&#34;
    if (r == 0 and g == 0 and b == 0) or g == -1:
        self.draw_color = f&#34;{r / 255:.3f} G&#34;
    else:
        self.draw_color = f&#34;{r / 255:.3f} {g / 255:.3f} {b / 255:.3f} RG&#34;
    if self.page &gt; 0:
        self._out(self.draw_color)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_fill_color"><code class="name flex">
<span>def <span class="ident">set_fill_color</span></span>(<span>self, r, g=-1, b=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Set color for all filling operations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_fill_color(self, r, g=-1, b=-1):
    &#34;&#34;&#34;Set color for all filling operations&#34;&#34;&#34;
    if (r == 0 and g == 0 and b == 0) or g == -1:
        self.fill_color = f&#34;{r / 255:.3f} g&#34;
    else:
        self.fill_color = f&#34;{r / 255:.3f} {g / 255:.3f} {b / 255:.3f} rg&#34;
    if self.page &gt; 0:
        self._out(self.fill_color)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_font"><code class="name flex">
<span>def <span class="ident">set_font</span></span>(<span>self, family=None, style='', size=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Select a font.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>family</code></strong> :&ensp;<code>str</code></dt>
<dd>name of a font added with <code><a title="fpdf.FPDF.add_font" href="#fpdf.FPDF.add_font">FPDF.add_font()</a></code>,
or name of one of the 14 standard "PostScript" fonts</dd>
<dt><strong><code>style</code></strong> :&ensp;<code>str</code></dt>
<dd>empty string (by default) or a combination
of one or several letters among B, I, U to</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code></dt>
<dd>in points</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_font(self, family=None, style=&#34;&#34;, size=0):
    &#34;&#34;&#34;
    Select a font.

    Args:
        family (str): name of a font added with `FPDF.add_font`,
          or name of one of the 14 standard &#34;PostScript&#34; fonts
        style (str): empty string (by default) or a combination
          of one or several letters among B, I, U to
        size (int): in points
    &#34;&#34;&#34;
    if not family:
        family = self.font_family
    if family.lower() == &#34;arial&#34; and (family + style) not in self.fonts:
        warnings.warn(&#34;Substitutting Arial by core font Helvetica&#34;)
        family = &#34;helvetica&#34;
    elif family.lower() in (&#34;symbol&#34;, &#34;zapfdingbats&#34;) and style:
        warnings.warn(
            &#39;Built-in fonts Symbol &amp; Zapfdingbats only have a single &#34;style&#34;&#39;
        )
        style = &#34;&#34;
    style = &#34;&#34;.join(sorted(style.upper()))
    if any(letter not in &#34;BIU&#34; for letter in style):
        raise ValueError(
            f&#34;Unknown style provided (only B/I/U letters are allowed): {style}&#34;
        )
    if &#34;U&#34; in style:
        self.underline = 1
        style = style.replace(&#34;U&#34;, &#34;&#34;)
    else:
        self.underline = 0
    if size == 0:
        size = self.font_size_pt

    # Test if font is already selected
    if (
        self.font_family == family
        and self.font_style == style
        and self.font_size_pt == size
    ):
        return

    # Test if used for the first time
    fontkey = family + style
    if fontkey not in self.fonts:
        # Being flexible: try a fontkey with lowercase family:
        fontkey_alt = family.lower() + style
        if fontkey_alt in self.fonts:
            fontkey = fontkey_alt
        else:
            if fontkey not in self.core_fonts or fontkey not in fpdf_charwidths:
                fontkey = fontkey_alt
                if fontkey not in self.core_fonts or fontkey not in fpdf_charwidths:
                    raise FPDFException(
                        &#34;Undefined font: &#34;
                        + fontkey
                        + &#34; - Use built-in fonts or FPDF.add_font() beforehand&#34;
                    )
            i = len(self.fonts) + 1
            self.fonts[fontkey] = {
                &#34;i&#34;: i,
                &#34;type&#34;: &#34;core&#34;,
                &#34;name&#34;: self.core_fonts[fontkey],
                &#34;up&#34;: -100,
                &#34;ut&#34;: 50,
                &#34;cw&#34;: fpdf_charwidths[fontkey],
            }

    # Select it
    self.font_family = family
    self.font_style = style
    self.font_size_pt = size
    self.font_size = size / self.k
    self.current_font = self.fonts[fontkey]
    self.unifontsubset = self.current_font[&#34;type&#34;] == &#34;TTF&#34;
    if self.page &gt; 0:
        self._out(f&#34;BT /F{self.current_font[&#39;i&#39;]} {self.font_size_pt:.2f} Tf ET&#34;)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_font_size"><code class="name flex">
<span>def <span class="ident">set_font_size</span></span>(<span>self, size)</span>
</code></dt>
<dd>
<div class="desc"><p>Set font size in points</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_font_size(self, size):
    &#34;&#34;&#34;Set font size in points&#34;&#34;&#34;
    if self.font_size_pt == size:
        return
    self.font_size_pt = size
    self.font_size = size / self.k
    if self.page &gt; 0:
        self._out(f&#34;BT /F{self.current_font[&#39;i&#39;]} {self.font_size_pt:.2f} Tf ET&#34;)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_keywords"><code class="name flex">
<span>def <span class="ident">set_keywords</span></span>(<span>self, keywords)</span>
</code></dt>
<dd>
<div class="desc"><p>Keywords of document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_keywords(self, keywords):
    &#34;&#34;&#34;Keywords of document&#34;&#34;&#34;
    self.keywords = keywords</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_left_margin"><code class="name flex">
<span>def <span class="ident">set_left_margin</span></span>(<span>self, margin)</span>
</code></dt>
<dd>
<div class="desc"><p>Set left margin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_left_margin(self, margin):
    &#34;&#34;&#34;Set left margin&#34;&#34;&#34;
    self.l_margin = margin
    if self.page &gt; 0 and self.x &lt; margin:
        self.x = margin</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_line_width"><code class="name flex">
<span>def <span class="ident">set_line_width</span></span>(<span>self, width)</span>
</code></dt>
<dd>
<div class="desc"><p>Set line width</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_line_width(self, width):
    &#34;&#34;&#34;Set line width&#34;&#34;&#34;
    self.line_width = width
    if self.page &gt; 0:
        self._out(f&#34;{width * self.k:.2f} w&#34;)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_link"><code class="name flex">
<span>def <span class="ident">set_link</span></span>(<span>self, link, y=0, page=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Set destination of internal link</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_link(self, link, y=0, page=-1):
    &#34;&#34;&#34;Set destination of internal link&#34;&#34;&#34;
    if y == -1:
        y = self.y
    if page == -1:
        page = self.page

    self.links[link] = [page, y]</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_margins"><code class="name flex">
<span>def <span class="ident">set_margins</span></span>(<span>self, left, top, right=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Set left, top and right margins</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_margins(self, left, top, right=-1):
    &#34;&#34;&#34;Set left, top and right margins&#34;&#34;&#34;
    self.l_margin = left
    self.t_margin = top
    if right == -1:
        right = left
    self.r_margin = right</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_right_margin"><code class="name flex">
<span>def <span class="ident">set_right_margin</span></span>(<span>self, margin)</span>
</code></dt>
<dd>
<div class="desc"><p>Set right margin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_right_margin(self, margin):
    &#34;&#34;&#34;Set right margin&#34;&#34;&#34;
    self.r_margin = margin</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_stretching"><code class="name flex">
<span>def <span class="ident">set_stretching</span></span>(<span>self, factor)</span>
</code></dt>
<dd>
<div class="desc"><p>Set from stretch factor percents (default: 100.0)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_stretching(self, factor):
    &#34;&#34;&#34;Set from stretch factor percents (default: 100.0)&#34;&#34;&#34;
    if self.font_stretching == factor:
        return
    self.font_stretching = factor
    if self.page &gt; 0:
        self._out(f&#34;BT {self.font_stretching:.2f} Tz ET&#34;)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_subject"><code class="name flex">
<span>def <span class="ident">set_subject</span></span>(<span>self, subject)</span>
</code></dt>
<dd>
<div class="desc"><p>Subject of document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_subject(self, subject):
    &#34;&#34;&#34;Subject of document&#34;&#34;&#34;
    self.subject = subject</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_text_color"><code class="name flex">
<span>def <span class="ident">set_text_color</span></span>(<span>self, r, g=-1, b=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Set color for text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_text_color(self, r, g=-1, b=-1):
    &#34;&#34;&#34;Set color for text&#34;&#34;&#34;
    if (r == 0 and g == 0 and b == 0) or g == -1:
        self.text_color = f&#34;{r / 255:.3f} g&#34;
    else:
        self.text_color = f&#34;{r / 255:.3f} {g / 255:.3f} {b / 255:.3f} rg&#34;</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_title"><code class="name flex">
<span>def <span class="ident">set_title</span></span>(<span>self, title)</span>
</code></dt>
<dd>
<div class="desc"><p>Title of document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_title(self, title):
    &#34;&#34;&#34;Title of document&#34;&#34;&#34;
    self.title = title</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_top_margin"><code class="name flex">
<span>def <span class="ident">set_top_margin</span></span>(<span>self, margin)</span>
</code></dt>
<dd>
<div class="desc"><p>Set top margin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_top_margin(self, margin):
    &#34;&#34;&#34;Set top margin&#34;&#34;&#34;
    self.t_margin = margin</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_x"><code class="name flex">
<span>def <span class="ident">set_x</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<div class="desc"><p>Set x position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_x(self, x):
    &#34;&#34;&#34;Set x position&#34;&#34;&#34;
    self.x = x if x &gt;= 0 else self.w + x</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_xy"><code class="name flex">
<span>def <span class="ident">set_xy</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Set x and y positions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_xy(self, x, y):
    &#34;&#34;&#34;Set x and y positions&#34;&#34;&#34;
    self.set_y(y)
    self.set_x(x)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_y"><code class="name flex">
<span>def <span class="ident">set_y</span></span>(<span>self, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Set y position and reset x</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_y(self, y):
    &#34;&#34;&#34;Set y position and reset x&#34;&#34;&#34;
    self.x = self.l_margin
    self.y = y if y &gt;= 0 else self.h + y</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.text"><code class="name flex">
<span>def <span class="ident">text</span></span>(<span>self, x, y, txt='')</span>
</code></dt>
<dd>
<div class="desc"><p>Output a string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def text(self, x, y, txt=&#34;&#34;):
    &#34;&#34;&#34;Output a string&#34;&#34;&#34;
    if not self.font_family:
        raise FPDFException(&#34;No font set, you need to call set_font() beforehand&#34;)
    txt = self.normalize_text(txt)
    if self.unifontsubset:
        txt2 = escape_parens(txt).encode(&#34;UTF-16BE&#34;).decode(&#34;latin-1&#34;)
        for char in txt:
            self.current_font[&#34;subset&#34;].append(ord(char))
    else:
        txt2 = escape_parens(txt)
    s = f&#34;BT {x * self.k:.2f} {(self.h - y) * self.k:.2f} Td ({txt2}) Tj ET&#34;
    if self.underline and txt != &#34;&#34;:
        s += &#34; &#34; + self._dounderline(x, y, txt)
    if self.fill_color != self.text_color:
        s = f&#34;q {self.text_color} {s} Q&#34;
    self._out(s)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.unbreakable"><code class="name flex">
<span>def <span class="ident">unbreakable</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Ensures that all rendering performed in this context appear on a single page
by performing page break beforehand if need be.</p>
<p>Note that using this method means to duplicate the FPDF <code>bytearray</code> buffer:
when generating large PDFs, doubling memory usage may be troublesome.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def unbreakable(self):
    &#34;&#34;&#34;
    Ensures that all rendering performed in this context appear on a single page
    by performing page break beforehand if need be.

    Note that using this method means to duplicate the FPDF `bytearray` buffer:
    when generating large PDFs, doubling memory usage may be troublesome.
    &#34;&#34;&#34;
    prev_page, prev_y = self.page, self.y
    recorder = FPDFRecorder(self, accept_page_break=False)
    yield recorder
    y_scroll = recorder.y - prev_y + (recorder.page - prev_page) * self.eph
    if prev_y + y_scroll &gt; self.page_break_trigger:
        LOGGER.debug(&#34;Performing page jump due to unbreakable height&#34;)
        recorder.rewind()
        assert recorder.perform_page_break_if_need_be(y_scroll)
        recorder.replay()</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, h, txt='', link='')</span>
</code></dt>
<dd>
<div class="desc"><p>Output text in flowing mode</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def write(self, h, txt=&#34;&#34;, link=&#34;&#34;):
    &#34;&#34;&#34;Output text in flowing mode&#34;&#34;&#34;
    if not self.font_family:
        raise FPDFException(&#34;No font set, you need to call set_font() beforehand&#34;)
    txt = self.normalize_text(txt)
    cw = self.current_font[&#34;cw&#34;]
    w = self.w - self.r_margin - self.x
    wmax = (w - 2 * self.c_margin) * 1000 / self.font_size
    s = txt.replace(&#34;\r&#34;, &#34;&#34;)
    nb = len(s)
    sep = -1
    i = 0
    j = 0
    l = 0
    nl = 1
    while i &lt; nb:
        # Get next character
        c = s[i]
        if c == &#34;\n&#34;:
            # Explicit line break
            self.cell(w, h, substr(s, j, i - j), 0, 2, &#34;&#34;, False, link)
            i += 1
            sep = -1
            j = i
            l = 0
            if nl == 1:
                self.x = self.l_margin
                w = self.w - self.r_margin - self.x
                wmax = (w - 2 * self.c_margin) * 1000 / self.font_size
            nl += 1
            continue
        if c == &#34; &#34;:
            sep = i
        if self.unifontsubset:
            l += self.get_string_width(c, True) / self.font_size * 1000
        else:
            l += cw.get(c, 0)
        if l &gt; wmax:
            # Automatic line break
            if sep == -1:
                if self.x &gt; self.l_margin:
                    # Move to next line
                    self.x = self.l_margin
                    self.y += h
                    w = self.w - self.r_margin - self.x
                    wmax = (w - 2 * self.c_margin) * 1000 / self.font_size
                    i += 1
                    nl += 1
                    continue
                if i == j:
                    i += 1
                self.cell(w, h, substr(s, j, i - j), 0, 2, &#34;&#34;, False, link)
            else:
                self.cell(w, h, substr(s, j, sep - j), 0, 2, &#34;&#34;, False, link)
                i = sep + 1
            sep = -1
            j = i
            l = 0
            if nl == 1:
                self.x = self.l_margin
                w = self.w - self.r_margin - self.x
                wmax = (w - 2 * self.c_margin) * 1000 / self.font_size
            nl += 1
        else:
            i += 1
    # Last chunk
    if i != j:
        self.cell(l / 1000 * self.font_size, h, substr(s, j), 0, 0, &#34;&#34;, False, link)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="fpdf.HTMLMixin"><code class="flex name class">
<span>class <span class="ident">HTMLMixin</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HTMLMixin:
    def write_html(self, text, *args, **kwargs):
        &#34;&#34;&#34;Parse HTML and convert it to PDF&#34;&#34;&#34;
        h2p = HTML2FPDF(self, *args, **kwargs)
        text = html.unescape(text)  # To deal with HTML entities
        h2p.feed(text)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="fpdf.HTMLMixin.write_html"><code class="name flex">
<span>def <span class="ident">write_html</span></span>(<span>self, text, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse HTML and convert it to PDF</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_html(self, text, *args, **kwargs):
    &#34;&#34;&#34;Parse HTML and convert it to PDF&#34;&#34;&#34;
    h2p = HTML2FPDF(self, *args, **kwargs)
    text = html.unescape(text)  # To deal with HTML entities
    h2p.feed(text)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="fpdf.Template"><code class="flex name class">
<span>class <span class="ident">Template</span></span>
<span>(</span><span>infile=None, elements=None, format='A4', orientation='portrait', title='', author='', subject='', creator='', keywords='')</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>infile</code></strong> :&ensp;<code>str</code></dt>
<dd>[<strong>DEPRECATED</strong>] unused, will be removed in a later version</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Template:
    # Disabling this check due to the &#34;format&#34; parameter below:
    # pylint: disable=redefined-builtin
    def __init__(
        self,
        infile=None,
        elements=None,
        format=&#34;A4&#34;,
        orientation=&#34;portrait&#34;,
        title=&#34;&#34;,
        author=&#34;&#34;,
        subject=&#34;&#34;,
        creator=&#34;&#34;,
        keywords=&#34;&#34;,
    ):
        &#34;&#34;&#34;
        Args:
            infile (str): [**DEPRECATED**] unused, will be removed in a later version
        &#34;&#34;&#34;
        if infile:
            warnings.warn(
                &#39;&#34;infile&#34; is unused and will soon be deprecated&#39;,
                PendingDeprecationWarning,
            )
        if elements:
            self.load_elements(elements)
        self.handlers = {
            &#34;T&#34;: self.text,
            &#34;L&#34;: self.line,
            &#34;I&#34;: self.image,
            &#34;B&#34;: self.rect,
            &#34;BC&#34;: self.barcode,
            &#34;W&#34;: self.write,
        }
        self.texts = {}
        pdf = self.pdf = FPDF(format=format, orientation=orientation, unit=&#34;mm&#34;)
        pdf.set_title(title)
        pdf.set_author(author)
        pdf.set_creator(creator)
        pdf.set_subject(subject)
        pdf.set_keywords(keywords)

    def load_elements(self, elements):
        &#34;&#34;&#34;Initialize the internal element structures&#34;&#34;&#34;
        self.pg_no = 0
        self.elements = elements
        self.keys = [v[&#34;name&#34;].lower() for v in self.elements]

    def parse_csv(self, infile, delimiter=&#34;,&#34;, decimal_sep=&#34;.&#34;):
        &#34;&#34;&#34;Parse template format csv file and create elements dict&#34;&#34;&#34;
        keys = (
            &#34;name&#34;,
            &#34;type&#34;,
            &#34;x1&#34;,
            &#34;y1&#34;,
            &#34;x2&#34;,
            &#34;y2&#34;,
            &#34;font&#34;,
            &#34;size&#34;,
            &#34;bold&#34;,
            &#34;italic&#34;,
            &#34;underline&#34;,
            &#34;foreground&#34;,
            &#34;background&#34;,
            &#34;align&#34;,
            &#34;text&#34;,
            &#34;priority&#34;,
            &#34;multiline&#34;,
        )
        self.elements = []
        self.pg_no = 0
        with open(infile) as f:
            for row in csv.reader(f, delimiter=delimiter):
                kargs = {}
                for i, v in enumerate(row):
                    if not v.startswith(&#34;&#39;&#34;) and decimal_sep != &#34;.&#34;:
                        v = v.replace(decimal_sep, &#34;.&#34;)
                    kargs[keys[i]] = v.strip()
                self.elements.append(kargs)
        self.keys = [v[&#34;name&#34;].lower() for v in self.elements]

    def add_page(self):
        self.pg_no += 1
        self.texts[self.pg_no] = {}

    def __setitem__(self, name, value):
        if name.lower() in self.keys:
            value = &#34;&#34; if value is None else str(value)
            self.texts[self.pg_no][name.lower()] = value

    # setitem shortcut (may be further extended)
    set = __setitem__

    def __contains__(self, name):
        return name.lower() in self.keys

    def __getitem__(self, name):
        if name in self.keys:
            key = name.lower()
            if key in self.texts:
                # text for this page:
                return self.texts[self.pg_no][key]
            # find first element for default text:
            elements = [
                element for element in self.elements if element[&#34;name&#34;].lower() == key
            ]
            if elements:
                return elements[0][&#34;text&#34;]
        return None

    def split_multicell(self, text, element_name):
        &#34;&#34;&#34;Divide (\n) a string using a given element width&#34;&#34;&#34;
        pdf = self.pdf
        element = [
            element
            for element in self.elements
            if element[&#34;name&#34;].lower() == element_name.lower()
        ][0]
        style = &#34;&#34;
        if element[&#34;bold&#34;]:
            style += &#34;B&#34;
        if element[&#34;italic&#34;]:
            style += &#34;I&#34;
        if element[&#34;underline&#34;]:
            style += &#34;U&#34;
        pdf.set_font(element[&#34;font&#34;], style, element[&#34;size&#34;])
        align = {&#34;L&#34;: &#34;L&#34;, &#34;R&#34;: &#34;R&#34;, &#34;I&#34;: &#34;L&#34;, &#34;D&#34;: &#34;R&#34;, &#34;C&#34;: &#34;C&#34;, &#34;&#34;: &#34;&#34;}.get(
            element[&#34;align&#34;]
        )  # D/I in spanish
        text = str(text)
        return pdf.multi_cell(
            w=element[&#34;x2&#34;] - element[&#34;x1&#34;],
            h=element[&#34;y2&#34;] - element[&#34;y1&#34;],
            txt=text,
            align=align,
            split_only=True,
        )

    def render(self, outfile=None, dest=None):
        &#34;&#34;&#34;
        Args:
            outfile (str): optional output PDF file path. If ommited, the
                `.pdf.output(...)` method can be manuallyy called afterwise.
            dest (str): [**DEPRECATED**] unused, will be removed in a later version
        &#34;&#34;&#34;
        if dest:
            warnings.warn(
                &#39;&#34;dest&#34; is unused and will soon be deprecated&#39;,
                PendingDeprecationWarning,
            )
        pdf = self.pdf
        for pg in range(1, self.pg_no + 1):
            pdf.add_page()
            pdf.set_font(&#34;helvetica&#34;, &#34;B&#34;, 16)
            pdf.set_auto_page_break(False, margin=0)

            for element in sorted(self.elements, key=lambda x: x[&#34;priority&#34;]):
                element = element.copy()
                element[&#34;text&#34;] = self.texts[pg].get(
                    element[&#34;name&#34;].lower(), element[&#34;text&#34;]
                )
                handler_name = element[&#34;type&#34;].upper()
                if &#34;rotate&#34; in element:
                    with pdf.rotation(element[&#34;rotate&#34;], element[&#34;x1&#34;], element[&#34;y1&#34;]):
                        self.handlers[handler_name](pdf, **element)
                else:
                    self.handlers[handler_name](pdf, **element)
        if outfile:
            pdf.output(outfile)

    @staticmethod
    def text(
        pdf,
        *_,
        x1=0,
        y1=0,
        x2=0,
        y2=0,
        text=&#34;&#34;,
        font=&#34;helvetica&#34;,
        size=10,
        bold=False,
        italic=False,
        underline=False,
        align=&#34;&#34;,
        foreground=0,
        backgroud=65535,
        multiline=None,
        **__,
    ):
        if not text:
            return
        if pdf.text_color != rgb(foreground):
            pdf.set_text_color(*rgb(foreground))
        if pdf.fill_color != rgb(backgroud):
            pdf.set_fill_color(*rgb(backgroud))

        font = font.strip().lower()
        if font == &#34;helvetica black&#34;:
            font = &#34;helvetica&#34;
        style = &#34;&#34;
        for tag in &#34;B&#34;, &#34;I&#34;, &#34;U&#34;:
            if text.startswith(f&#34;&lt;{tag}&gt;&#34;) and text.endswith(f&#34;&lt;/{tag}&gt;&#34;):
                text = text[3:-4]
                style += tag
        if bold:
            style += &#34;B&#34;
        if italic:
            style += &#34;I&#34;
        if underline:
            style += &#34;U&#34;
        align = {&#34;L&#34;: &#34;L&#34;, &#34;R&#34;: &#34;R&#34;, &#34;I&#34;: &#34;L&#34;, &#34;D&#34;: &#34;R&#34;, &#34;C&#34;: &#34;C&#34;, &#34;&#34;: &#34;&#34;}.get(
            align
        )  # D/I in spanish
        pdf.set_font(font, style, size)
        # m_k = 72 / 2.54
        # h = (size/m_k)
        pdf.set_xy(x1, y1)
        if multiline is None:
            # multiline==None: write without wrapping/trimming (default)
            pdf.cell(w=x2 - x1, h=y2 - y1, txt=text, border=0, ln=0, align=align)
        elif multiline:
            # multiline==True: automatic word - warp
            pdf.multi_cell(w=x2 - x1, h=y2 - y1, txt=text, border=0, align=align)
        else:
            # multiline==False: trim to fit exactly the space defined
            text = pdf.multi_cell(
                w=x2 - x1, h=y2 - y1, txt=text, align=align, split_only=True
            )[0]
            print(f&#34;trimming: *{text}*&#34;)
            pdf.cell(w=x2 - x1, h=y2 - y1, txt=text, border=0, ln=0, align=align)

            # pdf.Text(x=x1,y=y1,txt=text)

    @staticmethod
    def line(pdf, *_, x1=0, y1=0, x2=0, y2=0, size=0, foreground=0, **__):
        if pdf.draw_color != rgb(foreground):
            # print &#34;SetDrawColor&#34;, hex(foreground)
            pdf.set_draw_color(*rgb(foreground))
        # print &#34;SetLineWidth&#34;, size
        pdf.set_line_width(size)
        pdf.line(x1, y1, x2, y2)

    @staticmethod
    def rect(
        pdf, *_, x1=0, y1=0, x2=0, y2=0, size=0, foreground=0, backgroud=65535, **__
    ):
        if pdf.draw_color != rgb(foreground):
            pdf.set_draw_color(*rgb(foreground))
        if pdf.fill_color != rgb(backgroud):
            pdf.set_fill_color(*rgb(backgroud))
        pdf.set_line_width(size)
        pdf.rect(x1, y1, x2 - x1, y2 - y1)

    @staticmethod
    def image(pdf, *_, x1=0, y1=0, x2=0, y2=0, text=&#34;&#34;, **__):
        if text:
            pdf.image(text, x1, y1, w=x2 - x1, h=y2 - y1, link=&#34;&#34;)

    @staticmethod
    def barcode(
        pdf,
        *_,
        x1=0,
        y1=0,
        x2=0,
        y2=0,
        text=&#34;&#34;,
        font=&#34;helvetica&#34;,
        size=1,
        foreground=0,
        **__,
    ):
        # pylint: disable=unused-argument
        if pdf.draw_color != rgb(foreground):
            pdf.set_draw_color(*rgb(foreground))
        font = font.lower().strip()
        if font == &#34;interleaved 2of5 nt&#34;:
            pdf.interleaved2of5(text, x1, y1, w=size, h=y2 - y1)

    # Added by Derek Schwalenberg Schwalenberg1013@gmail.com to allow (url) links in
    # templates (using write method) 2014-02-22
    @staticmethod
    def write(
        pdf,
        *_,
        x1=0,
        y1=0,
        x2=0,
        y2=0,
        text=&#34;&#34;,
        font=&#34;helvetica&#34;,
        size=1,
        bold=False,
        italic=False,
        underline=False,
        align=&#34;&#34;,
        link=&#34;http://example.com&#34;,
        foreground=0,
        **__,
    ):
        # pylint: disable=unused-argument
        if pdf.text_color != rgb(foreground):
            pdf.set_text_color(*rgb(foreground))
        font = font.strip().lower()
        if font == &#34;helvetica black&#34;:
            font = &#34;helvetica&#34;
        style = &#34;&#34;
        for tag in &#34;B&#34;, &#34;I&#34;, &#34;U&#34;:
            if text.startswith(f&#34;&lt;{tag}&gt;&#34;) and text.endswith(f&#34;&lt;/{tag}&gt;&#34;):
                text = text[3:-4]
                style += tag
        if bold:
            style += &#34;B&#34;
        if italic:
            style += &#34;I&#34;
        if underline:
            style += &#34;U&#34;
        align = {&#34;L&#34;: &#34;L&#34;, &#34;R&#34;: &#34;R&#34;, &#34;I&#34;: &#34;L&#34;, &#34;D&#34;: &#34;R&#34;, &#34;C&#34;: &#34;C&#34;, &#34;&#34;: &#34;&#34;}.get(
            align
        )  # D/I in spanish
        pdf.set_font(font, style, size)
        # m_k = 72 / 2.54
        # h = (size/m_k)
        pdf.set_xy(x1, y1)
        pdf.write(5, text, link)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="fpdf.Template.barcode"><code class="name flex">
<span>def <span class="ident">barcode</span></span>(<span>pdf, *_, x1=0, y1=0, x2=0, y2=0, text='', font='helvetica', size=1, foreground=0, **__)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def barcode(
    pdf,
    *_,
    x1=0,
    y1=0,
    x2=0,
    y2=0,
    text=&#34;&#34;,
    font=&#34;helvetica&#34;,
    size=1,
    foreground=0,
    **__,
):
    # pylint: disable=unused-argument
    if pdf.draw_color != rgb(foreground):
        pdf.set_draw_color(*rgb(foreground))
    font = font.lower().strip()
    if font == &#34;interleaved 2of5 nt&#34;:
        pdf.interleaved2of5(text, x1, y1, w=size, h=y2 - y1)</code></pre>
</details>
</dd>
<dt id="fpdf.Template.image"><code class="name flex">
<span>def <span class="ident">image</span></span>(<span>pdf, *_, x1=0, y1=0, x2=0, y2=0, text='', **__)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def image(pdf, *_, x1=0, y1=0, x2=0, y2=0, text=&#34;&#34;, **__):
    if text:
        pdf.image(text, x1, y1, w=x2 - x1, h=y2 - y1, link=&#34;&#34;)</code></pre>
</details>
</dd>
<dt id="fpdf.Template.line"><code class="name flex">
<span>def <span class="ident">line</span></span>(<span>pdf, *_, x1=0, y1=0, x2=0, y2=0, size=0, foreground=0, **__)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def line(pdf, *_, x1=0, y1=0, x2=0, y2=0, size=0, foreground=0, **__):
    if pdf.draw_color != rgb(foreground):
        # print &#34;SetDrawColor&#34;, hex(foreground)
        pdf.set_draw_color(*rgb(foreground))
    # print &#34;SetLineWidth&#34;, size
    pdf.set_line_width(size)
    pdf.line(x1, y1, x2, y2)</code></pre>
</details>
</dd>
<dt id="fpdf.Template.rect"><code class="name flex">
<span>def <span class="ident">rect</span></span>(<span>pdf, *_, x1=0, y1=0, x2=0, y2=0, size=0, foreground=0, backgroud=65535, **__)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def rect(
    pdf, *_, x1=0, y1=0, x2=0, y2=0, size=0, foreground=0, backgroud=65535, **__
):
    if pdf.draw_color != rgb(foreground):
        pdf.set_draw_color(*rgb(foreground))
    if pdf.fill_color != rgb(backgroud):
        pdf.set_fill_color(*rgb(backgroud))
    pdf.set_line_width(size)
    pdf.rect(x1, y1, x2 - x1, y2 - y1)</code></pre>
</details>
</dd>
<dt id="fpdf.Template.text"><code class="name flex">
<span>def <span class="ident">text</span></span>(<span>pdf, *_, x1=0, y1=0, x2=0, y2=0, text='', font='helvetica', size=10, bold=False, italic=False, underline=False, align='', foreground=0, backgroud=65535, multiline=None, **__)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def text(
    pdf,
    *_,
    x1=0,
    y1=0,
    x2=0,
    y2=0,
    text=&#34;&#34;,
    font=&#34;helvetica&#34;,
    size=10,
    bold=False,
    italic=False,
    underline=False,
    align=&#34;&#34;,
    foreground=0,
    backgroud=65535,
    multiline=None,
    **__,
):
    if not text:
        return
    if pdf.text_color != rgb(foreground):
        pdf.set_text_color(*rgb(foreground))
    if pdf.fill_color != rgb(backgroud):
        pdf.set_fill_color(*rgb(backgroud))

    font = font.strip().lower()
    if font == &#34;helvetica black&#34;:
        font = &#34;helvetica&#34;
    style = &#34;&#34;
    for tag in &#34;B&#34;, &#34;I&#34;, &#34;U&#34;:
        if text.startswith(f&#34;&lt;{tag}&gt;&#34;) and text.endswith(f&#34;&lt;/{tag}&gt;&#34;):
            text = text[3:-4]
            style += tag
    if bold:
        style += &#34;B&#34;
    if italic:
        style += &#34;I&#34;
    if underline:
        style += &#34;U&#34;
    align = {&#34;L&#34;: &#34;L&#34;, &#34;R&#34;: &#34;R&#34;, &#34;I&#34;: &#34;L&#34;, &#34;D&#34;: &#34;R&#34;, &#34;C&#34;: &#34;C&#34;, &#34;&#34;: &#34;&#34;}.get(
        align
    )  # D/I in spanish
    pdf.set_font(font, style, size)
    # m_k = 72 / 2.54
    # h = (size/m_k)
    pdf.set_xy(x1, y1)
    if multiline is None:
        # multiline==None: write without wrapping/trimming (default)
        pdf.cell(w=x2 - x1, h=y2 - y1, txt=text, border=0, ln=0, align=align)
    elif multiline:
        # multiline==True: automatic word - warp
        pdf.multi_cell(w=x2 - x1, h=y2 - y1, txt=text, border=0, align=align)
    else:
        # multiline==False: trim to fit exactly the space defined
        text = pdf.multi_cell(
            w=x2 - x1, h=y2 - y1, txt=text, align=align, split_only=True
        )[0]
        print(f&#34;trimming: *{text}*&#34;)
        pdf.cell(w=x2 - x1, h=y2 - y1, txt=text, border=0, ln=0, align=align)

        # pdf.Text(x=x1,y=y1,txt=text)</code></pre>
</details>
</dd>
<dt id="fpdf.Template.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>pdf, *_, x1=0, y1=0, x2=0, y2=0, text='', font='helvetica', size=1, bold=False, italic=False, underline=False, align='', link='http://example.com', foreground=0, **__)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def write(
    pdf,
    *_,
    x1=0,
    y1=0,
    x2=0,
    y2=0,
    text=&#34;&#34;,
    font=&#34;helvetica&#34;,
    size=1,
    bold=False,
    italic=False,
    underline=False,
    align=&#34;&#34;,
    link=&#34;http://example.com&#34;,
    foreground=0,
    **__,
):
    # pylint: disable=unused-argument
    if pdf.text_color != rgb(foreground):
        pdf.set_text_color(*rgb(foreground))
    font = font.strip().lower()
    if font == &#34;helvetica black&#34;:
        font = &#34;helvetica&#34;
    style = &#34;&#34;
    for tag in &#34;B&#34;, &#34;I&#34;, &#34;U&#34;:
        if text.startswith(f&#34;&lt;{tag}&gt;&#34;) and text.endswith(f&#34;&lt;/{tag}&gt;&#34;):
            text = text[3:-4]
            style += tag
    if bold:
        style += &#34;B&#34;
    if italic:
        style += &#34;I&#34;
    if underline:
        style += &#34;U&#34;
    align = {&#34;L&#34;: &#34;L&#34;, &#34;R&#34;: &#34;R&#34;, &#34;I&#34;: &#34;L&#34;, &#34;D&#34;: &#34;R&#34;, &#34;C&#34;: &#34;C&#34;, &#34;&#34;: &#34;&#34;}.get(
        align
    )  # D/I in spanish
    pdf.set_font(font, style, size)
    # m_k = 72 / 2.54
    # h = (size/m_k)
    pdf.set_xy(x1, y1)
    pdf.write(5, text, link)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.Template.add_page"><code class="name flex">
<span>def <span class="ident">add_page</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_page(self):
    self.pg_no += 1
    self.texts[self.pg_no] = {}</code></pre>
</details>
</dd>
<dt id="fpdf.Template.load_elements"><code class="name flex">
<span>def <span class="ident">load_elements</span></span>(<span>self, elements)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the internal element structures</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_elements(self, elements):
    &#34;&#34;&#34;Initialize the internal element structures&#34;&#34;&#34;
    self.pg_no = 0
    self.elements = elements
    self.keys = [v[&#34;name&#34;].lower() for v in self.elements]</code></pre>
</details>
</dd>
<dt id="fpdf.Template.parse_csv"><code class="name flex">
<span>def <span class="ident">parse_csv</span></span>(<span>self, infile, delimiter=',', decimal_sep='.')</span>
</code></dt>
<dd>
<div class="desc"><p>Parse template format csv file and create elements dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_csv(self, infile, delimiter=&#34;,&#34;, decimal_sep=&#34;.&#34;):
    &#34;&#34;&#34;Parse template format csv file and create elements dict&#34;&#34;&#34;
    keys = (
        &#34;name&#34;,
        &#34;type&#34;,
        &#34;x1&#34;,
        &#34;y1&#34;,
        &#34;x2&#34;,
        &#34;y2&#34;,
        &#34;font&#34;,
        &#34;size&#34;,
        &#34;bold&#34;,
        &#34;italic&#34;,
        &#34;underline&#34;,
        &#34;foreground&#34;,
        &#34;background&#34;,
        &#34;align&#34;,
        &#34;text&#34;,
        &#34;priority&#34;,
        &#34;multiline&#34;,
    )
    self.elements = []
    self.pg_no = 0
    with open(infile) as f:
        for row in csv.reader(f, delimiter=delimiter):
            kargs = {}
            for i, v in enumerate(row):
                if not v.startswith(&#34;&#39;&#34;) and decimal_sep != &#34;.&#34;:
                    v = v.replace(decimal_sep, &#34;.&#34;)
                kargs[keys[i]] = v.strip()
            self.elements.append(kargs)
    self.keys = [v[&#34;name&#34;].lower() for v in self.elements]</code></pre>
</details>
</dd>
<dt id="fpdf.Template.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, outfile=None, dest=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>outfile</code></strong> :&ensp;<code>str</code></dt>
<dd>optional output PDF file path. If ommited, the
<code>.pdf.output(&hellip;)</code> method can be manuallyy called afterwise.</dd>
<dt><strong><code>dest</code></strong> :&ensp;<code>str</code></dt>
<dd>[<strong>DEPRECATED</strong>] unused, will be removed in a later version</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render(self, outfile=None, dest=None):
    &#34;&#34;&#34;
    Args:
        outfile (str): optional output PDF file path. If ommited, the
            `.pdf.output(...)` method can be manuallyy called afterwise.
        dest (str): [**DEPRECATED**] unused, will be removed in a later version
    &#34;&#34;&#34;
    if dest:
        warnings.warn(
            &#39;&#34;dest&#34; is unused and will soon be deprecated&#39;,
            PendingDeprecationWarning,
        )
    pdf = self.pdf
    for pg in range(1, self.pg_no + 1):
        pdf.add_page()
        pdf.set_font(&#34;helvetica&#34;, &#34;B&#34;, 16)
        pdf.set_auto_page_break(False, margin=0)

        for element in sorted(self.elements, key=lambda x: x[&#34;priority&#34;]):
            element = element.copy()
            element[&#34;text&#34;] = self.texts[pg].get(
                element[&#34;name&#34;].lower(), element[&#34;text&#34;]
            )
            handler_name = element[&#34;type&#34;].upper()
            if &#34;rotate&#34; in element:
                with pdf.rotation(element[&#34;rotate&#34;], element[&#34;x1&#34;], element[&#34;y1&#34;]):
                    self.handlers[handler_name](pdf, **element)
            else:
                self.handlers[handler_name](pdf, **element)
    if outfile:
        pdf.output(outfile)</code></pre>
</details>
</dd>
<dt id="fpdf.Template.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, name, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __setitem__(self, name, value):
    if name.lower() in self.keys:
        value = &#34;&#34; if value is None else str(value)
        self.texts[self.pg_no][name.lower()] = value</code></pre>
</details>
</dd>
<dt id="fpdf.Template.split_multicell"><code class="name flex">
<span>def <span class="ident">split_multicell</span></span>(<span>self, text, element_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Divide (
) a string using a given element width</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_multicell(self, text, element_name):
    &#34;&#34;&#34;Divide (\n) a string using a given element width&#34;&#34;&#34;
    pdf = self.pdf
    element = [
        element
        for element in self.elements
        if element[&#34;name&#34;].lower() == element_name.lower()
    ][0]
    style = &#34;&#34;
    if element[&#34;bold&#34;]:
        style += &#34;B&#34;
    if element[&#34;italic&#34;]:
        style += &#34;I&#34;
    if element[&#34;underline&#34;]:
        style += &#34;U&#34;
    pdf.set_font(element[&#34;font&#34;], style, element[&#34;size&#34;])
    align = {&#34;L&#34;: &#34;L&#34;, &#34;R&#34;: &#34;R&#34;, &#34;I&#34;: &#34;L&#34;, &#34;D&#34;: &#34;R&#34;, &#34;C&#34;: &#34;C&#34;, &#34;&#34;: &#34;&#34;}.get(
        element[&#34;align&#34;]
    )  # D/I in spanish
    text = str(text)
    return pdf.multi_cell(
        w=element[&#34;x2&#34;] - element[&#34;x1&#34;],
        h=element[&#34;y2&#34;] - element[&#34;y1&#34;],
        txt=text,
        align=align,
        split_only=True,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="fpdf.errors" href="errors.html">fpdf.errors</a></code></li>
<li><code><a title="fpdf.fonts" href="fonts.html">fpdf.fonts</a></code></li>
<li><code><a title="fpdf.fpdf" href="fpdf.html">fpdf.fpdf</a></code></li>
<li><code><a title="fpdf.html" href="html.html">fpdf.html</a></code></li>
<li><code><a title="fpdf.image_parsing" href="image_parsing.html">fpdf.image_parsing</a></code></li>
<li><code><a title="fpdf.recorder" href="recorder.html">fpdf.recorder</a></code></li>
<li><code><a title="fpdf.template" href="template.html">fpdf.template</a></code></li>
<li><code><a title="fpdf.ttfonts" href="ttfonts.html">fpdf.ttfonts</a></code></li>
<li><code><a title="fpdf.util" href="util/index.html">fpdf.util</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="fpdf.FPDF_CACHE_DIR" href="#fpdf.FPDF_CACHE_DIR">FPDF_CACHE_DIR</a></code></li>
<li><code><a title="fpdf.FPDF_FONT_DIR" href="#fpdf.FPDF_FONT_DIR">FPDF_FONT_DIR</a></code></li>
<li><code><a title="fpdf.FPDF_VERSION" href="#fpdf.FPDF_VERSION">FPDF_VERSION</a></code></li>
<li><code><a title="fpdf.SYSTEM_TTFONTS" href="#fpdf.SYSTEM_TTFONTS">SYSTEM_TTFONTS</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fpdf.FPDF" href="#fpdf.FPDF">FPDF</a></code></h4>
<ul class="">
<li><code><a title="fpdf.FPDF.accept_page_break" href="#fpdf.FPDF.accept_page_break">accept_page_break</a></code></li>
<li><code><a title="fpdf.FPDF.add_font" href="#fpdf.FPDF.add_font">add_font</a></code></li>
<li><code><a title="fpdf.FPDF.add_link" href="#fpdf.FPDF.add_link">add_link</a></code></li>
<li><code><a title="fpdf.FPDF.add_page" href="#fpdf.FPDF.add_page">add_page</a></code></li>
<li><code><a title="fpdf.FPDF.alias_nb_pages" href="#fpdf.FPDF.alias_nb_pages">alias_nb_pages</a></code></li>
<li><code><a title="fpdf.FPDF.cell" href="#fpdf.FPDF.cell">cell</a></code></li>
<li><code><a title="fpdf.FPDF.close" href="#fpdf.FPDF.close">close</a></code></li>
<li><code><a title="fpdf.FPDF.code39" href="#fpdf.FPDF.code39">code39</a></code></li>
<li><code><a title="fpdf.FPDF.dashed_line" href="#fpdf.FPDF.dashed_line">dashed_line</a></code></li>
<li><code><a title="fpdf.FPDF.ellipse" href="#fpdf.FPDF.ellipse">ellipse</a></code></li>
<li><code><a title="fpdf.FPDF.eph" href="#fpdf.FPDF.eph">eph</a></code></li>
<li><code><a title="fpdf.FPDF.epw" href="#fpdf.FPDF.epw">epw</a></code></li>
<li><code><a title="fpdf.FPDF.footer" href="#fpdf.FPDF.footer">footer</a></code></li>
<li><code><a title="fpdf.FPDF.get_string_width" href="#fpdf.FPDF.get_string_width">get_string_width</a></code></li>
<li><code><a title="fpdf.FPDF.get_x" href="#fpdf.FPDF.get_x">get_x</a></code></li>
<li><code><a title="fpdf.FPDF.get_y" href="#fpdf.FPDF.get_y">get_y</a></code></li>
<li><code><a title="fpdf.FPDF.header" href="#fpdf.FPDF.header">header</a></code></li>
<li><code><a title="fpdf.FPDF.image" href="#fpdf.FPDF.image">image</a></code></li>
<li><code><a title="fpdf.FPDF.interleaved2of5" href="#fpdf.FPDF.interleaved2of5">interleaved2of5</a></code></li>
<li><code><a title="fpdf.FPDF.line" href="#fpdf.FPDF.line">line</a></code></li>
<li><code><a title="fpdf.FPDF.link" href="#fpdf.FPDF.link">link</a></code></li>
<li><code><a title="fpdf.FPDF.ln" href="#fpdf.FPDF.ln">ln</a></code></li>
<li><code><a title="fpdf.FPDF.multi_cell" href="#fpdf.FPDF.multi_cell">multi_cell</a></code></li>
<li><code><a title="fpdf.FPDF.normalize_text" href="#fpdf.FPDF.normalize_text">normalize_text</a></code></li>
<li><code><a title="fpdf.FPDF.open" href="#fpdf.FPDF.open">open</a></code></li>
<li><code><a title="fpdf.FPDF.output" href="#fpdf.FPDF.output">output</a></code></li>
<li><code><a title="fpdf.FPDF.page_no" href="#fpdf.FPDF.page_no">page_no</a></code></li>
<li><code><a title="fpdf.FPDF.perform_page_break_if_need_be" href="#fpdf.FPDF.perform_page_break_if_need_be">perform_page_break_if_need_be</a></code></li>
<li><code><a title="fpdf.FPDF.rect" href="#fpdf.FPDF.rect">rect</a></code></li>
<li><code><a title="fpdf.FPDF.rect_clip" href="#fpdf.FPDF.rect_clip">rect_clip</a></code></li>
<li><code><a title="fpdf.FPDF.rotate" href="#fpdf.FPDF.rotate">rotate</a></code></li>
<li><code><a title="fpdf.FPDF.rotation" href="#fpdf.FPDF.rotation">rotation</a></code></li>
<li><code><a title="fpdf.FPDF.set_author" href="#fpdf.FPDF.set_author">set_author</a></code></li>
<li><code><a title="fpdf.FPDF.set_auto_page_break" href="#fpdf.FPDF.set_auto_page_break">set_auto_page_break</a></code></li>
<li><code><a title="fpdf.FPDF.set_compression" href="#fpdf.FPDF.set_compression">set_compression</a></code></li>
<li><code><a title="fpdf.FPDF.set_creation_date" href="#fpdf.FPDF.set_creation_date">set_creation_date</a></code></li>
<li><code><a title="fpdf.FPDF.set_creator" href="#fpdf.FPDF.set_creator">set_creator</a></code></li>
<li><code><a title="fpdf.FPDF.set_display_mode" href="#fpdf.FPDF.set_display_mode">set_display_mode</a></code></li>
<li><code><a title="fpdf.FPDF.set_doc_option" href="#fpdf.FPDF.set_doc_option">set_doc_option</a></code></li>
<li><code><a title="fpdf.FPDF.set_draw_color" href="#fpdf.FPDF.set_draw_color">set_draw_color</a></code></li>
<li><code><a title="fpdf.FPDF.set_fill_color" href="#fpdf.FPDF.set_fill_color">set_fill_color</a></code></li>
<li><code><a title="fpdf.FPDF.set_font" href="#fpdf.FPDF.set_font">set_font</a></code></li>
<li><code><a title="fpdf.FPDF.set_font_size" href="#fpdf.FPDF.set_font_size">set_font_size</a></code></li>
<li><code><a title="fpdf.FPDF.set_keywords" href="#fpdf.FPDF.set_keywords">set_keywords</a></code></li>
<li><code><a title="fpdf.FPDF.set_left_margin" href="#fpdf.FPDF.set_left_margin">set_left_margin</a></code></li>
<li><code><a title="fpdf.FPDF.set_line_width" href="#fpdf.FPDF.set_line_width">set_line_width</a></code></li>
<li><code><a title="fpdf.FPDF.set_link" href="#fpdf.FPDF.set_link">set_link</a></code></li>
<li><code><a title="fpdf.FPDF.set_margins" href="#fpdf.FPDF.set_margins">set_margins</a></code></li>
<li><code><a title="fpdf.FPDF.set_right_margin" href="#fpdf.FPDF.set_right_margin">set_right_margin</a></code></li>
<li><code><a title="fpdf.FPDF.set_stretching" href="#fpdf.FPDF.set_stretching">set_stretching</a></code></li>
<li><code><a title="fpdf.FPDF.set_subject" href="#fpdf.FPDF.set_subject">set_subject</a></code></li>
<li><code><a title="fpdf.FPDF.set_text_color" href="#fpdf.FPDF.set_text_color">set_text_color</a></code></li>
<li><code><a title="fpdf.FPDF.set_title" href="#fpdf.FPDF.set_title">set_title</a></code></li>
<li><code><a title="fpdf.FPDF.set_top_margin" href="#fpdf.FPDF.set_top_margin">set_top_margin</a></code></li>
<li><code><a title="fpdf.FPDF.set_x" href="#fpdf.FPDF.set_x">set_x</a></code></li>
<li><code><a title="fpdf.FPDF.set_xy" href="#fpdf.FPDF.set_xy">set_xy</a></code></li>
<li><code><a title="fpdf.FPDF.set_y" href="#fpdf.FPDF.set_y">set_y</a></code></li>
<li><code><a title="fpdf.FPDF.text" href="#fpdf.FPDF.text">text</a></code></li>
<li><code><a title="fpdf.FPDF.unbreakable" href="#fpdf.FPDF.unbreakable">unbreakable</a></code></li>
<li><code><a title="fpdf.FPDF.write" href="#fpdf.FPDF.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.HTMLMixin" href="#fpdf.HTMLMixin">HTMLMixin</a></code></h4>
<ul class="">
<li><code><a title="fpdf.HTMLMixin.write_html" href="#fpdf.HTMLMixin.write_html">write_html</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.Template" href="#fpdf.Template">Template</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.Template.add_page" href="#fpdf.Template.add_page">add_page</a></code></li>
<li><code><a title="fpdf.Template.barcode" href="#fpdf.Template.barcode">barcode</a></code></li>
<li><code><a title="fpdf.Template.image" href="#fpdf.Template.image">image</a></code></li>
<li><code><a title="fpdf.Template.line" href="#fpdf.Template.line">line</a></code></li>
<li><code><a title="fpdf.Template.load_elements" href="#fpdf.Template.load_elements">load_elements</a></code></li>
<li><code><a title="fpdf.Template.parse_csv" href="#fpdf.Template.parse_csv">parse_csv</a></code></li>
<li><code><a title="fpdf.Template.rect" href="#fpdf.Template.rect">rect</a></code></li>
<li><code><a title="fpdf.Template.render" href="#fpdf.Template.render">render</a></code></li>
<li><code><a title="fpdf.Template.set" href="#fpdf.Template.set">set</a></code></li>
<li><code><a title="fpdf.Template.split_multicell" href="#fpdf.Template.split_multicell">split_multicell</a></code></li>
<li><code><a title="fpdf.Template.text" href="#fpdf.Template.text">text</a></code></li>
<li><code><a title="fpdf.Template.write" href="#fpdf.Template.write">write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>